{
  "version": 3,
  "sources": ["../../src/compiler/lexer.js", "../../src/ast/nodes.js", "../../src/compiler/parser.js"],
  "sourcesContent": ["// flux-core/src/compiler/lexer.js\n// Tokenizes Flux source code into tokens\n\nexport class FluxLexer {\n  constructor(source) {\n    this.source = source;\n    this.position = 0;\n    this.start = 0;\n    this.line = 1;\n    this.column = 1;\n    this.tokens = [];\n    this.errors = [];\n  }\n\n  // Token types\n  static TOKEN_TYPES = {\n    // Literals\n    IDENTIFIER: 'IDENTIFIER',\n    NUMBER: 'NUMBER',\n    STRING: 'STRING',\n    BOOLEAN: 'BOOLEAN',\n\n    // Keywords\n    COMPONENT: 'COMPONENT',\n    STATE: 'STATE',\n    PROP: 'PROP',\n    METHOD: 'METHOD',\n    RENDER: 'RENDER',\n    EFFECT: 'EFFECT',\n    COMPUTED: 'COMPUTED',\n    STORE: 'STORE',\n    ACTION: 'ACTION',\n    LIFECYCLE: 'LIFECYCLE',\n    GUARD: 'GUARD',\n    ROUTER: 'ROUTER',\n    ROUTE: 'ROUTE',\n    USE: 'USE',\n    IMPORT: 'IMPORT',\n    EXPORT: 'EXPORT',\n    ASYNC: 'ASYNC',\n    AWAIT: 'AWAIT',\n    IF: 'IF',\n    ELSE: 'ELSE',\n    FOR: 'FOR',\n    WHILE: 'WHILE',\n    RETURN: 'RETURN',\n    TRY: 'TRY',\n    CATCH: 'CATCH',\n    FINALLY: 'FINALLY',\n    ON: 'ON',\n\n    // Operators\n    ASSIGN: 'ASSIGN',\n    PLUS_ASSIGN: 'PLUS_ASSIGN',\n    MINUS_ASSIGN: 'MINUS_ASSIGN',\n    PLUS: 'PLUS',\n    MINUS: 'MINUS',\n    MULTIPLY: 'MULTIPLY',\n    DIVIDE: 'DIVIDE',\n    MODULO: 'MODULO',\n    EQUALS: 'EQUALS',\n    NOT_EQUALS: 'NOT_EQUALS',\n    LESS_THAN: 'LESS_THAN',\n    GREATER_THAN: 'GREATER_THAN',\n    LESS_EQUAL: 'LESS_EQUAL',\n    GREATER_EQUAL: 'GREATER_EQUAL',\n    LOGICAL_AND: 'LOGICAL_AND',\n    LOGICAL_OR: 'LOGICAL_OR',\n    LOGICAL_NOT: 'LOGICAL_NOT',\n\n    // Delimiters\n    LEFT_PAREN: 'LEFT_PAREN',\n    RIGHT_PAREN: 'RIGHT_PAREN',\n    LEFT_BRACE: 'LEFT_BRACE',\n    RIGHT_BRACE: 'RIGHT_BRACE',\n    LEFT_BRACKET: 'LEFT_BRACKET',\n    RIGHT_BRACKET: 'RIGHT_BRACKET',\n    SEMICOLON: 'SEMICOLON',\n    COMMA: 'COMMA',\n    DOT: 'DOT',\n    COLON: 'COLON',\n    QUESTION: 'QUESTION',\n\n    // JSX-like tokens\n    JSX_OPEN: 'JSX_OPEN',\n    JSX_CLOSE: 'JSX_CLOSE',\n    JSX_SELF_CLOSE: 'JSX_SELF_CLOSE',\n    JSX_TEXT: 'JSX_TEXT',\n\n    // Arrow function\n    ARROW: 'ARROW',\n\n    // Decorators\n    AT: 'AT',\n\n    // Special\n    NEWLINE: 'NEWLINE',\n    EOF: 'EOF',\n    UNKNOWN: 'UNKNOWN',\n  };\n\n  static KEYWORDS = {\n    'component': 'COMPONENT',\n    'state': 'STATE',\n    'prop': 'PROP',\n    'method': 'METHOD',\n    'render': 'RENDER',\n    'effect': 'EFFECT',\n    'computed': 'COMPUTED',\n    'store': 'STORE',\n    'action': 'ACTION',\n    'lifecycle': 'LIFECYCLE',\n    'guard': 'GUARD',\n    'router': 'ROUTER',\n    'route': 'ROUTE',\n    'use': 'USE',\n    'import': 'IMPORT',\n    'export': 'EXPORT',\n    'on': 'ON',\n    'async': 'ASYNC',\n    'await': 'AWAIT',\n    'if': 'IF',\n    'else': 'ELSE',\n    'for': 'FOR',\n    'while': 'WHILE',\n    'return': 'RETURN',\n    'try': 'TRY',\n    'catch': 'CATCH',\n    'finally': 'FINALLY',\n    'true': 'BOOLEAN',\n    'false': 'BOOLEAN',\n    'null': 'BOOLEAN',\n    'undefined': 'BOOLEAN',\n  };\n\n  tokenize() {\n    while (!this.isAtEnd()) {\n      this.scanToken();\n    }\n\n    this.addToken(FluxLexer.TOKEN_TYPES.EOF);\n    return this.tokens;\n  }\n\n  scanToken() {\n    this.start = this.position;\n    const c = this.advance();\n\n    switch (c) {\n    case ' ':\n    case '\\r':\n    case '\\t':\n      break; // Ignore whitespace\n\n    case '\\n':\n      this.line++;\n      this.column = 1;\n      this.addToken(FluxLexer.TOKEN_TYPES.NEWLINE);\n      break;\n\n    case '(':\n      this.addToken(FluxLexer.TOKEN_TYPES.LEFT_PAREN);\n      break;\n    case ')':\n      this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_PAREN);\n      break;\n    case '{':\n      this.addToken(FluxLexer.TOKEN_TYPES.LEFT_BRACE);\n      break;\n    case '}':\n      this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_BRACE);\n      break;\n    case '[':\n      this.addToken(FluxLexer.TOKEN_TYPES.LEFT_BRACKET);\n      break;\n    case ']':\n      this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_BRACKET);\n      break;\n    case ';':\n      this.addToken(FluxLexer.TOKEN_TYPES.SEMICOLON);\n      break;\n    case ',':\n      this.addToken(FluxLexer.TOKEN_TYPES.COMMA);\n      break;\n    case '.':\n      this.addToken(FluxLexer.TOKEN_TYPES.DOT);\n      break;\n    case ':':\n      this.addToken(FluxLexer.TOKEN_TYPES.COLON);\n      break;\n    case '?':\n      this.addToken(FluxLexer.TOKEN_TYPES.QUESTION);\n      break;\n    case '@':\n      this.addToken(FluxLexer.TOKEN_TYPES.AT);\n      break;\n\n    case '+':\n      this.addToken(this.match('=') ?\n        FluxLexer.TOKEN_TYPES.PLUS_ASSIGN :\n        FluxLexer.TOKEN_TYPES.PLUS,\n      );\n      break;\n    case '-':\n      this.addToken(this.match('=') ?\n        FluxLexer.TOKEN_TYPES.MINUS_ASSIGN :\n        FluxLexer.TOKEN_TYPES.MINUS,\n      );\n      break;\n    case '*':\n      this.addToken(FluxLexer.TOKEN_TYPES.MULTIPLY);\n      break;\n    case '%':\n      this.addToken(FluxLexer.TOKEN_TYPES.MODULO);\n      break;\n\n    case '!':\n      this.addToken(this.match('=') ?\n        FluxLexer.TOKEN_TYPES.NOT_EQUALS :\n        FluxLexer.TOKEN_TYPES.LOGICAL_NOT,\n      );\n      break;\n    case '=':\n      if (this.match('=')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.EQUALS);\n      } else if (this.match('>')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.ARROW);\n      } else {\n        this.addToken(FluxLexer.TOKEN_TYPES.ASSIGN);\n      }\n      break;\n    case '<':\n      if (this.peek() === '/') {\n        this.advance(); // consume '/'\n        this.addToken(FluxLexer.TOKEN_TYPES.JSX_CLOSE);\n      } else if (this.match('=')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.LESS_EQUAL);\n      } else {\n        this.addToken(FluxLexer.TOKEN_TYPES.JSX_OPEN);\n      }\n      break;\n    case '>':\n      this.addToken(this.match('=') ?\n        FluxLexer.TOKEN_TYPES.GREATER_EQUAL :\n        FluxLexer.TOKEN_TYPES.GREATER_THAN,\n      );\n      break;\n\n    case '&':\n      if (this.match('&')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.LOGICAL_AND);\n      }\n      break;\n    case '|':\n      if (this.match('|')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.LOGICAL_OR);\n      }\n      break;\n\n    case '/':\n      if (this.match('/')) {\n        // Single line comment\n        while (this.peek() !== '\\n' && !this.isAtEnd()) {\n          this.advance();\n        }\n      } else if (this.match('*')) {\n        // Multi-line comment\n        this.blockComment();\n      } else if (this.match('>')) {\n        this.addToken(FluxLexer.TOKEN_TYPES.JSX_SELF_CLOSE);\n      } else {\n        this.addToken(FluxLexer.TOKEN_TYPES.DIVIDE);\n      }\n      break;\n\n    case '\"':\n    case '\\'':\n      this.string(c);\n      break;\n\n    default:\n      if (this.isDigit(c)) {\n        this.number();\n      } else if (this.isAlpha(c)) {\n        this.identifier();\n      } else {\n        this.addToken(FluxLexer.TOKEN_TYPES.UNKNOWN, c);\n      }\n      break;\n    }\n  }\n\n  identifier() {\n    while (this.isAlphaNumeric(this.peek())) {\n      this.advance();\n    }\n\n    const text = this.source.substring(this.start, this.position);\n    const type = FluxLexer.KEYWORDS[text] || FluxLexer.TOKEN_TYPES.IDENTIFIER;\n    this.addToken(type, text);\n  }\n\n  number() {\n    while (this.isDigit(this.peek())) {\n      this.advance();\n    }\n\n    // Look for decimal part\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      this.advance(); // consume '.'\n      while (this.isDigit(this.peek())) {\n        this.advance();\n      }\n    }\n\n    const value = parseFloat(this.source.substring(this.start, this.position));\n    this.addToken(FluxLexer.TOKEN_TYPES.NUMBER, value);\n  }\n\n  string(quote) {\n    while (this.peek() !== quote && !this.isAtEnd()) {\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      throw new Error(`Unterminated string at line ${this.line}`);\n    }\n\n    this.advance(); // closing quote\n\n    const value = this.source.substring(this.start + 1, this.position - 1);\n    this.addToken(FluxLexer.TOKEN_TYPES.STRING, value);\n  }\n\n  blockComment() {\n    while (!this.isAtEnd()) {\n      if (this.peek() === '*' && this.peekNext() === '/') {\n        this.advance(); // consume '*'\n        this.advance(); // consume '/'\n        break;\n      }\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n  }\n\n  match(expected) {\n    if (this.isAtEnd()) return false;\n    if (this.source.charAt(this.position) !== expected) return false;\n\n    this.position++;\n    this.column++;\n    return true;\n  }\n\n  peek() {\n    if (this.isAtEnd()) return '\\0';\n    return this.source.charAt(this.position);\n  }\n\n  peekNext() {\n    if (this.position + 1 >= this.source.length) return '\\0';\n    return this.source.charAt(this.position + 1);\n  }\n\n  isAlpha(c) {\n    return (c >= 'a' && c <= 'z') ||\n           (c >= 'A' && c <= 'Z') ||\n           c === '_';\n  }\n\n  isAlphaNumeric(c) {\n    return this.isAlpha(c) || this.isDigit(c);\n  }\n\n  isDigit(c) {\n    return c >= '0' && c <= '9';\n  }\n\n  isAtEnd() {\n    return this.position >= this.source.length;\n  }\n\n  advance() {\n    this.column++;\n    return this.source.charAt(this.position++);\n  }\n\n  addToken(type, literal = null) {\n    let text;\n    if (type === FluxLexer.TOKEN_TYPES.EOF) {\n      text = '';\n    } else {\n      text = this.source.substring(this.start, this.position);\n    }\n    this.tokens.push({\n      type,\n      lexeme: text,\n      literal,\n      line: this.line,\n      column: this.column - text.length,\n    });\n  }\n}\n", "// flux-core/src/ast/nodes.js\n// Abstract Syntax Tree node definitions for Flux language\n\nexport class ASTNode {\n  constructor(type, location) {\n    this.type = type;\n    this.location = location;\n  }\n}\n\n// Program root\nexport class Program extends ASTNode {\n  constructor(body, location) {\n    super('Program', location);\n    this.body = body; // Array of top-level statements\n  }\n}\n\n// Imports and Exports\nexport class ImportDeclaration extends ASTNode {\n  constructor(specifiers, source, location) {\n    super('ImportDeclaration', location);\n    this.specifiers = specifiers;\n    this.source = source;\n  }\n}\n\nexport class ImportSpecifier extends ASTNode {\n  constructor(imported, local, location) {\n    super('ImportSpecifier', location);\n    this.imported = imported;\n    this.local = local;\n  }\n}\n\nexport class ExportDeclaration extends ASTNode {\n  constructor(declaration, location) {\n    super('ExportDeclaration', location);\n    this.declaration = declaration;\n  }\n}\n\n// Component Declaration\nexport class ComponentDeclaration extends ASTNode {\n  constructor(name, decorators, body, location) {\n    super('ComponentDeclaration', location);\n    this.name = name;\n    this.decorators = decorators || [];\n    this.body = body;\n    this.state = [];\n    this.props = [];\n    this.methods = [];\n    this.effects = [];\n    this.computed = [];\n    this.render = null;\n    this.lifecycle = [];\n\n    // Organize body items\n    this.organizeBody();\n  }\n\n  organizeBody() {\n    for (const item of this.body) {\n      switch (item.type) {\n      case 'StateDeclaration':\n        this.state.push(item);\n        break;\n      case 'PropDeclaration':\n        this.props.push(item);\n        break;\n      case 'MethodDeclaration':\n        this.methods.push(item);\n        break;\n      case 'EffectDeclaration':\n        this.effects.push(item);\n        break;\n      case 'ComputedDeclaration':\n        this.computed.push(item);\n        break;\n      case 'RenderDeclaration':\n        this.render = item;\n        break;\n      case 'LifecycleDeclaration':\n        this.lifecycle.push(item);\n        break;\n      }\n    }\n  }\n}\n\n// Store Declaration\nexport class StoreDeclaration extends ASTNode {\n  constructor(name, body, location) {\n    super('StoreDeclaration', location);\n    this.name = name;\n    this.body = body;\n    this.state = [];\n    this.actions = [];\n    this.computed = [];\n\n    this.organizeBody();\n  }\n\n  organizeBody() {\n    for (const item of this.body) {\n      switch (item.type) {\n      case 'StateDeclaration':\n        this.state.push(item);\n        break;\n      case 'ActionDeclaration':\n        this.actions.push(item);\n        break;\n      case 'ComputedDeclaration':\n        this.computed.push(item);\n        break;\n      }\n    }\n  }\n}\n\n// Declarations\nexport class StateDeclaration extends ASTNode {\n  constructor(name, initialValue, typeAnnotation, location) {\n    super('StateDeclaration', location);\n    this.name = name;\n    this.initialValue = initialValue;\n    this.typeAnnotation = typeAnnotation;\n  }\n}\n\nexport class PropDeclaration extends ASTNode {\n  constructor(name, typeAnnotation, defaultValue, location) {\n    super('PropDeclaration', location);\n    this.name = name;\n    this.typeAnnotation = typeAnnotation;\n    this.defaultValue = defaultValue;\n  }\n}\n\nexport class MethodDeclaration extends ASTNode {\n  constructor(name, parameters, body, isAsync, location) {\n    super('MethodDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\nexport class ActionDeclaration extends ASTNode {\n  constructor(name, parameters, body, isAsync, location) {\n    super('ActionDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\nexport class EffectDeclaration extends ASTNode {\n  constructor(dependencies, body, location) {\n    super('EffectDeclaration', location);\n    this.dependencies = dependencies;\n    this.body = body;\n  }\n}\n\nexport class ComputedDeclaration extends ASTNode {\n  constructor(name, body, location) {\n    super('ComputedDeclaration', location);\n    this.name = name;\n    this.body = body;\n  }\n}\n\nexport class RenderDeclaration extends ASTNode {\n  constructor(body, location) {\n    super('RenderDeclaration', location);\n    this.body = body;\n  }\n}\n\nexport class LifecycleDeclaration extends ASTNode {\n  constructor(phase, body, isAsync, location) {\n    super('LifecycleDeclaration', location);\n    this.phase = phase; // 'mounted', 'updated', 'unmounted', etc.\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\n// Decorators\nexport class Decorator extends ASTNode {\n  constructor(name, arguments_, location) {\n    super('Decorator', location);\n    this.name = name;\n    this.arguments = arguments_ || [];\n  }\n}\n\n// Expressions\nexport class BinaryExpression extends ASTNode {\n  constructor(left, operator, right, location) {\n    super('BinaryExpression', location);\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n}\n\nexport class UnaryExpression extends ASTNode {\n  constructor(operator, operand, location) {\n    super('UnaryExpression', location);\n    this.operator = operator;\n    this.operand = operand;\n  }\n}\n\nexport class AssignmentExpression extends ASTNode {\n  constructor(left, operator, right, location) {\n    super('AssignmentExpression', location);\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n}\n\nexport class CallExpression extends ASTNode {\n  constructor(callee, arguments_, location) {\n    super('CallExpression', location);\n    this.callee = callee;\n    this.arguments = arguments_;\n  }\n}\n\nexport class MemberExpression extends ASTNode {\n  constructor(object, property, computed, location) {\n    super('MemberExpression', location);\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n}\n\nexport class ConditionalExpression extends ASTNode {\n  constructor(test, consequent, alternate, location) {\n    super('ConditionalExpression', location);\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n}\n\nexport class ArrayExpression extends ASTNode {\n  constructor(elements, location) {\n    super('ArrayExpression', location);\n    this.elements = elements;\n  }\n}\n\nexport class ObjectExpression extends ASTNode {\n  constructor(properties, location) {\n    super('ObjectExpression', location);\n    this.properties = properties;\n  }\n}\n\nexport class Property extends ASTNode {\n  constructor(key, value, kind, location) {\n    super('Property', location);\n    this.key = key;\n    this.value = value;\n    this.kind = kind || 'init';\n  }\n}\n\n// Literals\nexport class Literal extends ASTNode {\n  constructor(value, location) {\n    super('Literal', location);\n    this.value = value;\n  }\n}\n\nexport class Identifier extends ASTNode {\n  constructor(name, location) {\n    super('Identifier', location);\n    this.name = name;\n  }\n}\n\n// JSX-like Nodes\nexport class JSXElement extends ASTNode {\n  constructor(openingElement, children, closingElement, location) {\n    super('JSXElement', location);\n    this.openingElement = openingElement;\n    this.children = children;\n    this.closingElement = closingElement;\n    this.selfClosing = !closingElement;\n  }\n}\n\nexport class JSXOpeningElement extends ASTNode {\n  constructor(name, attributes, selfClosing, location) {\n    super('JSXOpeningElement', location);\n    this.name = name;\n    this.attributes = attributes;\n    this.selfClosing = selfClosing;\n  }\n}\n\nexport class JSXClosingElement extends ASTNode {\n  constructor(name, location) {\n    super('JSXClosingElement', location);\n    this.name = name;\n  }\n}\n\nexport class JSXAttribute extends ASTNode {\n  constructor(name, value, location) {\n    super('JSXAttribute', location);\n    this.name = name;\n    this.value = value;\n  }\n}\n\nexport class JSXExpressionContainer extends ASTNode {\n  constructor(expression, location) {\n    super('JSXExpressionContainer', location);\n    this.expression = expression;\n  }\n}\n\nexport class JSXText extends ASTNode {\n  constructor(value, location) {\n    super('JSXText', location);\n    this.value = value;\n  }\n}\n\n// Statements\nexport class ExpressionStatement extends ASTNode {\n  constructor(expression, location) {\n    super('ExpressionStatement', location);\n    this.expression = expression;\n  }\n}\n\nexport class BlockStatement extends ASTNode {\n  constructor(body, location) {\n    super('BlockStatement', location);\n    this.body = body;\n  }\n}\n\nexport class IfStatement extends ASTNode {\n  constructor(test, consequent, alternate, location) {\n    super('IfStatement', location);\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n}\n\nexport class WhileStatement extends ASTNode {\n  constructor(test, body, location) {\n    super('WhileStatement', location);\n    this.test = test;\n    this.body = body;\n  }\n}\n\nexport class ForStatement extends ASTNode {\n  constructor(init, test, update, body, location) {\n    super('ForStatement', location);\n    this.init = init;\n    this.test = test;\n    this.update = update;\n    this.body = body;\n  }\n}\n\nexport class ReturnStatement extends ASTNode {\n  constructor(argument, location) {\n    super('ReturnStatement', location);\n    this.argument = argument;\n  }\n}\n\nexport class TryStatement extends ASTNode {\n  constructor(block, handler, finalizer, location) {\n    super('TryStatement', location);\n    this.block = block;\n    this.handler = handler;\n    this.finalizer = finalizer;\n  }\n}\n\nexport class CatchClause extends ASTNode {\n  constructor(param, body, location) {\n    super('CatchClause', location);\n    this.param = param;\n    this.body = body;\n  }\n}\n\nexport class ThrowStatement extends ASTNode {\n  constructor(argument, location) {\n    super('ThrowStatement', location);\n    this.argument = argument;\n  }\n}\n\nexport class VariableDeclaration extends ASTNode {\n  constructor(declarations, kind, location) {\n    super('VariableDeclaration', location);\n    this.declarations = declarations;\n    this.kind = kind; // 'var', 'let', 'const'\n  }\n}\n\nexport class VariableDeclarator extends ASTNode {\n  constructor(id, init, location) {\n    super('VariableDeclarator', location);\n    this.id = id;\n    this.init = init;\n  }\n}\n\n// Route specific nodes\nexport class RouteDeclaration extends ASTNode {\n  constructor(path, component, guards, loaders, meta, location) {\n    super('RouteDeclaration', location);\n    this.path = path;\n    this.component = component;\n    this.guards = guards || [];\n    this.loaders = loaders || [];\n    this.meta = meta;\n  }\n}\n\nexport class GuardDeclaration extends ASTNode {\n  constructor(name, parameters, body, location) {\n    super('GuardDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n  }\n}\n\n// Type annotations\nexport class TypeAnnotation extends ASTNode {\n  constructor(typeAnnotation, location) {\n    super('TypeAnnotation', location);\n    this.typeAnnotation = typeAnnotation;\n  }\n}\n\nexport class TSStringKeyword extends ASTNode {\n  constructor(location) {\n    super('TSStringKeyword', location);\n  }\n}\n\nexport class TSNumberKeyword extends ASTNode {\n  constructor(location) {\n    super('TSNumberKeyword', location);\n  }\n}\n\nexport class TSBooleanKeyword extends ASTNode {\n  constructor(location) {\n    super('TSBooleanKeyword', location);\n  }\n}\n\nexport class TSArrayType extends ASTNode {\n  constructor(elementType, location) {\n    super('TSArrayType', location);\n    this.elementType = elementType;\n  }\n}\n\nexport class TSUnionType extends ASTNode {\n  constructor(types, location) {\n    super('TSUnionType', location);\n    this.types = types;\n  }\n}\n\nexport class ArrowFunctionExpression extends ASTNode {\n  constructor(params, body, location) {\n    super('ArrowFunctionExpression', location);\n    this.params = params;\n    this.body = body;\n  }\n}\n\n// Utility function to create location object\nexport function createLocation(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: { line: startLine, column: startColumn },\n    end: { line: endLine, column: endColumn },\n  };\n}\n", "// flux-core/src/compiler/parser.js\n// Recursive descent parser for Flux language\n\nimport { FluxLexer } from './lexer.js';\nimport * as AST from '../ast/nodes.js';\n\nexport class FluxParser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.errors = [];\n  }\n\n  static parse(source) {\n    const lexer = new FluxLexer(source);\n    const tokens = lexer.tokenize();\n    const parser = new FluxParser(tokens);\n    return parser.program();\n  }\n\n  program() {\n    const body = [];\n\n    while (!this.isAtEnd()) {\n      // Skip newlines at top level\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n\n      const stmt = this.topLevelStatement();\n      if (stmt) body.push(stmt);\n    }\n\n    return new AST.Program(body, this.getCurrentLocation());\n  }\n\n  topLevelStatement() {\n    try {\n      if (this.match('IMPORT')) {\n        return this.importDeclaration();\n      }\n\n      if (this.match('EXPORT')) {\n        return this.exportDeclaration();\n      }\n\n      // Handle decorators\n      const decorators = [];\n      while (this.check('AT')) {\n        decorators.push(this.decorator());\n      }\n\n      if (this.match('COMPONENT')) {\n        return this.componentDeclaration(decorators);\n      }\n\n      if (this.match('STORE')) {\n        return this.storeDeclaration(decorators);\n      }\n\n      if (this.match('GUARD')) {\n        return this.guardDeclaration(decorators);\n      }\n\n      return this.statement();\n    } catch (error) {\n      this.synchronize();\n      throw error;\n    }\n  }\n\n  importDeclaration() {\n    const specifiers = [];\n\n    if (this.check('LEFT_BRACE')) {\n      // Named imports: import { name1, name2 } from 'module'\n      this.consume('LEFT_BRACE', 'Expected \"{\"');\n\n      do {\n        const imported = this.consume('IDENTIFIER', 'Expected identifier');\n        let local = imported;\n\n        if (this.match('AS')) {\n          local = this.consume('IDENTIFIER', 'Expected identifier after \"as\"');\n        }\n\n        specifiers.push(new AST.ImportSpecifier(\n          new AST.Identifier(imported.lexeme),\n          new AST.Identifier(local.lexeme),\n        ));\n      } while (this.match('COMMA'));\n\n      this.consume('RIGHT_BRACE', 'Expected \"}\"');\n    } else {\n      // Default import: import name from 'module'\n      const name = this.consume('IDENTIFIER', 'Expected identifier');\n      specifiers.push(new AST.ImportSpecifier(\n        new AST.Identifier('default'),\n        new AST.Identifier(name.lexeme),\n      ));\n    }\n\n    this.consume('FROM', 'Expected \"from\"');\n    const source = this.consume('STRING', 'Expected module path');\n\n    return new AST.ImportDeclaration(\n      specifiers,\n      new AST.Literal(source.literal),\n      this.getCurrentLocation(),\n    );\n  }\n\n  exportDeclaration() {\n    const declaration = this.topLevelStatement();\n    return new AST.ExportDeclaration(declaration, this.getCurrentLocation());\n  }\n\n  decorator() {\n    this.consume('AT', 'Expected \"@\"');\n    const name = this.consume('IDENTIFIER', 'Expected decorator name');\n\n    let args = [];\n    if (this.match('LEFT_PAREN')) {\n      args = this.argumentList();\n      this.consume('RIGHT_PAREN', 'Expected \")\"');\n    }\n\n    return new AST.Decorator(\n      new AST.Identifier(name.lexeme),\n      args,\n      this.getCurrentLocation(),\n    );\n  }\n\n  componentDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected component name');\n\n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n\n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n\n      const member = this.componentMember();\n      if (member) body.push(member);\n    }\n\n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n\n    return new AST.ComponentDeclaration(\n      new AST.Identifier(name.lexeme),\n      decorators,\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  componentMember() {\n    if (this.match('STATE')) {\n      return this.stateDeclaration();\n    }\n\n    if (this.match('PROP')) {\n      return this.propDeclaration();\n    }\n\n    if (this.match('METHOD')) {\n      return this.methodDeclaration();\n    }\n\n    if (this.match('EFFECT')) {\n      return this.effectDeclaration();\n    }\n\n    if (this.match('COMPUTED')) {\n      return this.computedDeclaration();\n    }\n\n    if (this.match('RENDER')) {\n      return this.renderDeclaration();\n    }\n\n    if (this.match('LIFECYCLE')) {\n      return this.lifecycleDeclaration();\n    }\n\n    return this.statement();\n  }\n\n  stateDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected state variable name');\n\n    let typeAnnotation = null;\n    if (this.match('COLON')) {\n      typeAnnotation = this.typeAnnotation();\n    }\n\n    let initialValue = null;\n    if (this.match('ASSIGN')) {\n      initialValue = this.expression();\n    }\n\n    return new AST.StateDeclaration(\n      new AST.Identifier(name.lexeme),\n      initialValue,\n      typeAnnotation,\n      this.getCurrentLocation(),\n    );\n  }\n\n  propDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected prop name');\n\n    let typeAnnotation = null;\n    if (this.match('COLON')) {\n      typeAnnotation = this.typeAnnotation();\n    }\n\n    let defaultValue = null;\n    if (this.match('ASSIGN')) {\n      defaultValue = this.expression();\n    }\n\n    return new AST.PropDeclaration(\n      new AST.Identifier(name.lexeme),\n      typeAnnotation,\n      defaultValue,\n      this.getCurrentLocation(),\n    );\n  }\n\n  methodDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const name = this.consume('IDENTIFIER', 'Expected method name');\n\n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n\n    const body = this.blockStatement();\n\n    return new AST.MethodDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      isAsync,\n      this.getCurrentLocation(),\n    );\n  }\n\n  effectDeclaration() {\n    const dependencies = [];\n\n    if (this.match('ON')) {\n      // effect on dependency1, dependency2 { ... }\n      dependencies.push(this.expression());\n\n      while (this.match('COMMA')) {\n        dependencies.push(this.expression());\n      }\n    }\n\n    const body = this.blockStatement();\n\n    return new AST.EffectDeclaration(\n      dependencies,\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  computedDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected computed property name');\n\n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n\n    const body = this.blockStatement();\n\n    return new AST.ComputedDeclaration(\n      new AST.Identifier(name.lexeme),\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  renderDeclaration() {\n    const body = this.blockStatement();\n\n    return new AST.RenderDeclaration(\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  lifecycleDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const phase = this.consume('IDENTIFIER', 'Expected lifecycle phase');\n\n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n\n    const body = this.blockStatement();\n\n    return new AST.LifecycleDeclaration(\n      phase.lexeme,\n      body,\n      isAsync,\n      this.getCurrentLocation(),\n    );\n  }\n\n  storeDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected store name');\n\n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n\n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n\n      const member = this.storeMember();\n      if (member) body.push(member);\n    }\n\n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n\n    return new AST.StoreDeclaration(\n      new AST.Identifier(name.lexeme),\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  storeMember() {\n    if (this.match('STATE')) {\n      return this.stateDeclaration();\n    }\n\n    if (this.match('ACTION')) {\n      return this.actionDeclaration();\n    }\n\n    if (this.match('COMPUTED')) {\n      return this.computedDeclaration();\n    }\n\n    return this.statement();\n  }\n\n  actionDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const name = this.consume('IDENTIFIER', 'Expected action name');\n\n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n\n    const body = this.blockStatement();\n\n    return new AST.ActionDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      isAsync,\n      this.getCurrentLocation(),\n    );\n  }\n\n  guardDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected guard name');\n\n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n\n    const body = this.blockStatement();\n\n    return new AST.GuardDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      this.getCurrentLocation(),\n    );\n  }\n\n  // Statements\n  statement() {\n    if (this.match('IF')) {\n      return this.ifStatement();\n    }\n\n    if (this.match('WHILE')) {\n      return this.whileStatement();\n    }\n\n    if (this.match('FOR')) {\n      return this.forStatement();\n    }\n\n    if (this.match('RETURN')) {\n      return this.returnStatement();\n    }\n\n    if (this.match('TRY')) {\n      return this.tryStatement();\n    }\n\n    if (this.match('LEFT_BRACE')) {\n      return this.blockStatement();\n    }\n\n    return this.expressionStatement();\n  }\n\n  ifStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"if\"');\n    const test = this.expression();\n    this.consume('RIGHT_PAREN', 'Expected \")\" after if condition');\n\n    const consequent = this.statement();\n    let alternate = null;\n\n    if (this.match('ELSE')) {\n      alternate = this.statement();\n    }\n\n    return new AST.IfStatement(test, consequent, alternate, this.getCurrentLocation());\n  }\n\n  whileStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"while\"');\n    const test = this.expression();\n    this.consume('RIGHT_PAREN', 'Expected \")\" after while condition');\n\n    const body = this.statement();\n\n    return new AST.WhileStatement(test, body, this.getCurrentLocation());\n  }\n\n  forStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"for\"');\n\n    let init = null;\n    if (!this.check('SEMICOLON')) {\n      init = this.expression();\n    }\n    this.consume('SEMICOLON', 'Expected \";\" after for loop initializer');\n\n    let test = null;\n    if (!this.check('SEMICOLON')) {\n      test = this.expression();\n    }\n    this.consume('SEMICOLON', 'Expected \";\" after for loop condition');\n\n    let update = null;\n    if (!this.check('RIGHT_PAREN')) {\n      update = this.expression();\n    }\n    this.consume('RIGHT_PAREN', 'Expected \")\" after for clauses');\n\n    const body = this.statement();\n\n    return new AST.ForStatement(init, test, update, body, this.getCurrentLocation());\n  }\n\n  returnStatement() {\n    let argument = null;\n\n    if (!this.check('NEWLINE') && !this.check('SEMICOLON')) {\n      argument = this.expression();\n    }\n\n    return new AST.ReturnStatement(argument, this.getCurrentLocation());\n  }\n\n  tryStatement() {\n    const block = this.blockStatement();\n\n    let handler = null;\n    if (this.match('CATCH')) {\n      this.consume('LEFT_PAREN', 'Expected \"(\" after \"catch\"');\n      const param = this.consume('IDENTIFIER', 'Expected catch parameter');\n      this.consume('RIGHT_PAREN', 'Expected \")\" after catch parameter');\n\n      const body = this.blockStatement();\n      handler = new AST.CatchClause(\n        new AST.Identifier(param.lexeme),\n        body,\n        this.getCurrentLocation(),\n      );\n    }\n\n    let finalizer = null;\n    if (this.match('FINALLY')) {\n      finalizer = this.blockStatement();\n    }\n\n    return new AST.TryStatement(block, handler, finalizer, this.getCurrentLocation());\n  }\n\n  blockStatement() {\n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n\n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n\n      body.push(this.statement());\n    }\n\n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n\n    return new AST.BlockStatement(body, this.getCurrentLocation());\n  }\n\n  expressionStatement() {\n    const expr = this.expression();\n    return new AST.ExpressionStatement(expr, this.getCurrentLocation());\n  }\n\n  // Expressions\n  expression() {\n    return this.assignment();\n  }\n\n  assignment() {\n    const expr = this.ternary();\n\n    if (this.match('ASSIGN', 'PLUS_ASSIGN', 'MINUS_ASSIGN')) {\n      const operator = this.previous();\n      const value = this.assignment();\n\n      if (expr.type !== 'Identifier') {\n        throw new Error('Invalid assignment target');\n      }\n\n      return new AST.AssignmentExpression(\n        expr,\n        operator.lexeme,\n        value,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  ternary() {\n    let expr = this.logicalOr();\n\n    if (this.match('QUESTION')) {\n      const consequent = this.expression();\n      this.consume('COLON', 'Expected \":\" in ternary expression');\n      const alternate = this.ternary();\n\n      expr = new AST.ConditionalExpression(\n        expr,\n        consequent,\n        alternate,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  logicalOr() {\n    let expr = this.logicalAnd();\n\n    while (this.match('LOGICAL_OR')) {\n      const operator = this.previous();\n      const right = this.logicalAnd();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  logicalAnd() {\n    let expr = this.equality();\n\n    while (this.match('LOGICAL_AND')) {\n      const operator = this.previous();\n      const right = this.equality();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  equality() {\n    let expr = this.comparison();\n\n    while (this.match('EQUALS', 'NOT_EQUALS')) {\n      const operator = this.previous();\n      const right = this.comparison();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  comparison() {\n    let expr = this.addition();\n\n    while (this.match('GREATER_THAN', 'GREATER_EQUAL', 'LESS_THAN', 'LESS_EQUAL')) {\n      const operator = this.previous();\n      const right = this.addition();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  addition() {\n    let expr = this.multiplication();\n\n    while (this.match('PLUS', 'MINUS')) {\n      const operator = this.previous();\n      const right = this.multiplication();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  multiplication() {\n    let expr = this.unary();\n\n    while (this.match('MULTIPLY', 'DIVIDE', 'MODULO')) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return expr;\n  }\n\n  unary() {\n    if (this.match('LOGICAL_NOT', 'MINUS', 'PLUS')) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new AST.UnaryExpression(\n        operator.lexeme,\n        right,\n        this.getCurrentLocation(),\n      );\n    }\n\n    return this.postfix();\n  }\n\n  postfix() {\n    let expr = this.primary();\n\n    while (true) {\n      if (this.match('LEFT_PAREN')) {\n        // Function call\n        const args = this.argumentList();\n        this.consume('RIGHT_PAREN', 'Expected \")\" after arguments');\n\n        expr = new AST.CallExpression(\n          expr,\n          args,\n          this.getCurrentLocation(),\n        );\n      } else if (this.match('LEFT_BRACKET')) {\n        // Array access\n        const index = this.expression();\n        this.consume('RIGHT_BRACKET', 'Expected \"]\" after array index');\n\n        expr = new AST.MemberExpression(\n          expr,\n          index,\n          true, // computed\n          this.getCurrentLocation(),\n        );\n      } else if (this.match('DOT')) {\n        // Property access\n        const property = this.consume('IDENTIFIER', 'Expected property name');\n\n        expr = new AST.MemberExpression(\n          expr,\n          new AST.Identifier(property.lexeme),\n          false, // not computed\n          this.getCurrentLocation(),\n        );\n      } else if (this.match('ARROW')) {\n        // Arrow function\n        const params = [];\n        if (this.check('LEFT_PAREN')) {\n          this.advance(); // consume '('\n          if (!this.check('RIGHT_PAREN')) {\n            do {\n              params.push(this.consume('IDENTIFIER', 'Expected parameter name'));\n            } while (this.match('COMMA'));\n          }\n          this.consume('RIGHT_PAREN', 'Expected \")\" after parameters');\n        } else {\n          params.push(this.consume('IDENTIFIER', 'Expected parameter name'));\n        }\n\n        let body;\n        if (this.check('LEFT_BRACE')) {\n          body = this.blockStatement();\n        } else {\n          body = this.expression();\n        }\n\n        expr = new AST.ArrowFunctionExpression(\n          params.map(p => new AST.Identifier(p.lexeme)),\n          body,\n          this.getCurrentLocation(),\n        );\n      } else {\n        break;\n      }\n    }\n\n    return expr;\n  }\n\n  primary() {\n    if (this.match('BOOLEAN')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n\n    if (this.match('NUMBER')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n\n    if (this.match('STRING')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n\n    if (this.match('IDENTIFIER')) {\n      return new AST.Identifier(this.previous().lexeme, this.getCurrentLocation());\n    }\n\n    if (this.match('LEFT_PAREN')) {\n      const expr = this.expression();\n      this.consume('RIGHT_PAREN', 'Expected \")\" after expression');\n      return expr;\n    }\n\n    if (this.match('LEFT_BRACKET')) {\n      // Array literal\n      const elements = [];\n\n      if (!this.check('RIGHT_BRACKET')) {\n        do {\n          elements.push(this.expression());\n        } while (this.match('COMMA'));\n      }\n\n      this.consume('RIGHT_BRACKET', 'Expected \"]\" after array elements');\n\n      return new AST.ArrayExpression(elements, this.getCurrentLocation());\n    }\n\n    if (this.match('LEFT_BRACE')) {\n      // Object literal\n      const properties = [];\n\n      if (!this.check('RIGHT_BRACE')) {\n        do {\n          if (this.check('NEWLINE')) {\n            this.advance();\n            continue;\n          }\n\n          let key;\n          if (this.match('STRING')) {\n            key = new AST.Literal(this.previous().literal);\n          } else {\n            const name = this.consume('IDENTIFIER', 'Expected property name');\n            key = new AST.Identifier(name.lexeme);\n          }\n\n          this.consume('COLON', 'Expected \":\" after property name');\n          const value = this.expression();\n\n          properties.push(new AST.Property(key, value, 'init', this.getCurrentLocation()));\n        } while (this.match('COMMA'));\n      }\n\n      this.consume('RIGHT_BRACE', 'Expected \"}\" after object properties');\n\n      return new AST.ObjectExpression(properties, this.getCurrentLocation());\n    }\n\n    // JSX Element\n    if (this.check('JSX_OPEN')) {\n      return this.jsxElement();\n    }\n\n    throw new Error(`Unexpected token: ${this.peek().lexeme} at line ${this.peek().line}`);\n  }\n\n  jsxElement() {\n    this.consume('JSX_OPEN', 'Expected \"<\"');\n\n    // Element name\n    const name = this.consume('IDENTIFIER', 'Expected element name');\n    const elementName = new AST.Identifier(name.lexeme);\n\n    // Attributes\n    const attributes = [];\n    while (!this.check('GREATER_THAN') && !this.check('JSX_SELF_CLOSE') && !this.isAtEnd()) {\n      attributes.push(this.jsxAttribute());\n    }\n\n    // Self-closing tag\n    if (this.match('JSX_SELF_CLOSE')) {\n      return new AST.JSXElement(\n        new AST.JSXOpeningElement(elementName, attributes, true),\n        [],\n        null,\n        this.getCurrentLocation(),\n      );\n    }\n\n    this.consume('GREATER_THAN', 'Expected \">\" after opening tag');\n\n    // Children\n    const children = [];\n    while (!this.check('JSX_CLOSE') && !this.isAtEnd()) {\n      if (this.check('JSX_OPEN') && this.peekNext().type === 'IDENTIFIER') {\n        // Nested element\n        children.push(this.jsxElement());\n      } else if (this.check('LEFT_BRACE')) {\n        // Expression\n        this.advance(); // consume '{'\n        const expr = this.expression();\n        this.consume('RIGHT_BRACE', 'Expected \"}\" after JSX expression');\n        children.push(new AST.JSXExpressionContainer(expr));\n      } else {\n        // Text content\n        let text = '';\n        while (!this.check('JSX_OPEN') && !this.check('JSX_CLOSE') && !this.check('LEFT_BRACE') && !this.isAtEnd()) {\n          text += this.advance().lexeme;\n        }\n        if (text.trim()) {\n          children.push(new AST.JSXText(text.trim()));\n        }\n      }\n    }\n\n    // Closing tag\n    this.consume('JSX_CLOSE', 'Expected closing tag');\n    const closingName = this.consume('IDENTIFIER', 'Expected closing tag name');\n    this.consume('GREATER_THAN', 'Expected \">\" after closing tag');\n\n    if (closingName.lexeme !== name.lexeme) {\n      throw new Error(`Mismatched JSX tags: ${name.lexeme} and ${closingName.lexeme}`);\n    }\n\n    return new AST.JSXElement(\n      new AST.JSXOpeningElement(elementName, attributes, false),\n      children,\n      new AST.JSXClosingElement(new AST.Identifier(closingName.lexeme)),\n      this.getCurrentLocation(),\n    );\n  }\n\n  jsxAttribute() {\n    let name;\n    if (this.check('AT')) {\n      this.advance(); // consume '@'\n      const eventName = this.consume('IDENTIFIER', 'Expected event name after @');\n      name = new AST.Identifier(`@${eventName.lexeme}`);\n    } else {\n      const attrName = this.consume('IDENTIFIER', 'Expected attribute name');\n      name = new AST.Identifier(attrName.lexeme);\n    }\n\n    if (this.match('ASSIGN')) {\n      let value;\n      if (this.match('STRING')) {\n        value = new AST.Literal(this.previous().literal);\n      } else if (this.match('LEFT_BRACE')) {\n        const expr = this.expression();\n        this.consume('RIGHT_BRACE', 'Expected \"}\" after JSX expression');\n        value = new AST.JSXExpressionContainer(expr);\n      } else {\n        throw new Error('Expected attribute value');\n      }\n\n      return new AST.JSXAttribute(\n        new AST.Identifier(name.lexeme),\n        value,\n        this.getCurrentLocation(),\n      );\n    }\n\n    // Boolean attribute\n    return new AST.JSXAttribute(\n      new AST.Identifier(name.lexeme),\n      new AST.Literal(true),\n      this.getCurrentLocation(),\n    );\n  }\n\n  parameterList() {\n    const parameters = [];\n\n    if (!this.check('RIGHT_PAREN')) {\n      do {\n        const name = this.consume('IDENTIFIER', 'Expected parameter name');\n\n        let typeAnnotation = null;\n        if (this.match('COLON')) {\n          typeAnnotation = this.typeAnnotation();\n        }\n\n        let defaultValue = null;\n        if (this.match('ASSIGN')) {\n          defaultValue = this.expression();\n        }\n\n        parameters.push({\n          name: new AST.Identifier(name.lexeme),\n          typeAnnotation,\n          defaultValue,\n        });\n      } while (this.match('COMMA'));\n    }\n\n    return parameters;\n  }\n\n  argumentList() {\n    const args = [];\n\n    if (!this.check('RIGHT_PAREN')) {\n      do {\n        args.push(this.expression());\n      } while (this.match('COMMA'));\n    }\n\n    return args;\n  }\n\n  typeAnnotation() {\n    if (this.match('IDENTIFIER')) {\n      const typeName = this.previous().lexeme;\n\n      switch (typeName) {\n      case 'string':\n        return new AST.TSStringKeyword();\n      case 'number':\n        return new AST.TSNumberKeyword();\n      case 'boolean':\n        return new AST.TSBooleanKeyword();\n      default:\n        return new AST.Identifier(typeName);\n      }\n    }\n\n    throw new Error('Expected type annotation');\n  }\n\n  // Utility methods\n  match(...types) {\n    for (const type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  check(type) {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  advance() {\n    if (!this.isAtEnd()) this.current++;\n    return this.previous();\n  }\n\n  isAtEnd() {\n    return this.peek().type === 'EOF';\n  }\n\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  peekNext() {\n    if (this.current + 1 >= this.tokens.length) {\n      return this.tokens[this.tokens.length - 1]; // EOF\n    }\n    return this.tokens[this.current + 1];\n  }\n\n  previous() {\n    return this.tokens[this.current - 1];\n  }\n\n  consume(type, message) {\n    if (this.check(type)) return this.advance();\n\n    const current = this.peek();\n    throw new Error(`${message}. Got ${current.type} \"${current.lexeme}\" at line ${current.line}`);\n  }\n\n  synchronize() {\n    this.advance();\n\n    while (!this.isAtEnd()) {\n      if (this.previous().type === 'NEWLINE') return;\n\n      switch (this.peek().type) {\n      case 'COMPONENT':\n      case 'STORE':\n      case 'GUARD':\n      case 'IF':\n      case 'FOR':\n      case 'WHILE':\n      case 'RETURN':\n        return;\n      }\n\n      this.advance();\n    }\n  }\n\n  getCurrentLocation() {\n    const token = this.peek();\n    return AST.createLocation(token.line, token.column, token.line, token.column);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
