{
  "version": 3,
  "sources": ["../../src/compiler/lexer.js", "../../src/ast/nodes.js", "../../src/compiler/parser.js", "../../src/compiler/codegen.js", "../../src/errors.js", "../../src/compiler/index.js"],
  "sourcesContent": ["// flux-core/src/compiler/lexer.js\n// Tokenizes Flux source code into tokens\n\nexport class FluxLexer {\n  constructor(source) {\n    this.source = source;\n    this.position = 0;\n    this.start = 0;\n    this.line = 1;\n    this.column = 1;\n    this.tokens = [];\n    this.errors = [];\n  }\n\n  // Token types\n  static TOKEN_TYPES = {\n    // Literals\n    IDENTIFIER: 'IDENTIFIER',\n    NUMBER: 'NUMBER',\n    STRING: 'STRING',\n    BOOLEAN: 'BOOLEAN',\n    \n    // Keywords\n    COMPONENT: 'COMPONENT',\n    STATE: 'STATE',\n    PROP: 'PROP',\n    METHOD: 'METHOD',\n    RENDER: 'RENDER',\n    EFFECT: 'EFFECT',\n    COMPUTED: 'COMPUTED',\n    STORE: 'STORE',\n    ACTION: 'ACTION',\n    LIFECYCLE: 'LIFECYCLE',\n    GUARD: 'GUARD',\n    ROUTER: 'ROUTER',\n    ROUTE: 'ROUTE',\n    USE: 'USE',\n    IMPORT: 'IMPORT',\n    EXPORT: 'EXPORT',\n    ASYNC: 'ASYNC',\n    AWAIT: 'AWAIT',\n    IF: 'IF',\n    ELSE: 'ELSE',\n    FOR: 'FOR',\n    WHILE: 'WHILE',\n    RETURN: 'RETURN',\n    TRY: 'TRY',\n    CATCH: 'CATCH',\n    FINALLY: 'FINALLY',\n    \n    // Operators\n    ASSIGN: 'ASSIGN',\n    PLUS_ASSIGN: 'PLUS_ASSIGN',\n    MINUS_ASSIGN: 'MINUS_ASSIGN',\n    PLUS: 'PLUS',\n    MINUS: 'MINUS',\n    MULTIPLY: 'MULTIPLY',\n    DIVIDE: 'DIVIDE',\n    MODULO: 'MODULO',\n    EQUALS: 'EQUALS',\n    NOT_EQUALS: 'NOT_EQUALS',\n    LESS_THAN: 'LESS_THAN',\n    GREATER_THAN: 'GREATER_THAN',\n    LESS_EQUAL: 'LESS_EQUAL',\n    GREATER_EQUAL: 'GREATER_EQUAL',\n    LOGICAL_AND: 'LOGICAL_AND',\n    LOGICAL_OR: 'LOGICAL_OR',\n    LOGICAL_NOT: 'LOGICAL_NOT',\n    \n    // Delimiters\n    LEFT_PAREN: 'LEFT_PAREN',\n    RIGHT_PAREN: 'RIGHT_PAREN',\n    LEFT_BRACE: 'LEFT_BRACE',\n    RIGHT_BRACE: 'RIGHT_BRACE',\n    LEFT_BRACKET: 'LEFT_BRACKET',\n    RIGHT_BRACKET: 'RIGHT_BRACKET',\n    SEMICOLON: 'SEMICOLON',\n    COMMA: 'COMMA',\n    DOT: 'DOT',\n    COLON: 'COLON',\n    QUESTION: 'QUESTION',\n    \n    // JSX-like tokens\n    JSX_OPEN: 'JSX_OPEN',\n    JSX_CLOSE: 'JSX_CLOSE',\n    JSX_SELF_CLOSE: 'JSX_SELF_CLOSE',\n    JSX_TEXT: 'JSX_TEXT',\n    \n    // Decorators\n    AT: 'AT',\n    \n    // Special\n    NEWLINE: 'NEWLINE',\n    EOF: 'EOF',\n    UNKNOWN: 'UNKNOWN'\n  };\n\n  static KEYWORDS = {\n    'component': 'COMPONENT',\n    'state': 'STATE',\n    'prop': 'PROP',\n    'method': 'METHOD',\n    'render': 'RENDER',\n    'effect': 'EFFECT',\n    'computed': 'COMPUTED',\n    'store': 'STORE',\n    'action': 'ACTION',\n    'lifecycle': 'LIFECYCLE',\n    'guard': 'GUARD',\n    'router': 'ROUTER',\n    'route': 'ROUTE',\n    'use': 'USE',\n    'import': 'IMPORT',\n    'export': 'EXPORT',\n    'async': 'ASYNC',\n    'await': 'AWAIT',\n    'if': 'IF',\n    'else': 'ELSE',\n    'for': 'FOR',\n    'while': 'WHILE',\n    'return': 'RETURN',\n    'try': 'TRY',\n    'catch': 'CATCH',\n    'finally': 'FINALLY',\n    'true': 'BOOLEAN',\n    'false': 'BOOLEAN',\n    'null': 'BOOLEAN',\n    'undefined': 'BOOLEAN'\n  };\n\n  tokenize() {\n    while (!this.isAtEnd()) {\n      this.scanToken();\n    }\n    \n    this.addToken(FluxLexer.TOKEN_TYPES.EOF);\n    return this.tokens;\n  }\n\n  scanToken() {\n    this.start = this.position;\n    const c = this.advance();\n    \n    switch (c) {\n      case ' ':\n      case '\\r':\n      case '\\t':\n        break; // Ignore whitespace\n      \n      case '\\n':\n        this.line++;\n        this.column = 1;\n        this.addToken(FluxLexer.TOKEN_TYPES.NEWLINE);\n        break;\n      \n      case '(':\n        this.addToken(FluxLexer.TOKEN_TYPES.LEFT_PAREN);\n        break;\n      case ')':\n        this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_PAREN);\n        break;\n      case '{':\n        this.addToken(FluxLexer.TOKEN_TYPES.LEFT_BRACE);\n        break;\n      case '}':\n        this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_BRACE);\n        break;\n      case '[':\n        this.addToken(FluxLexer.TOKEN_TYPES.LEFT_BRACKET);\n        break;\n      case ']':\n        this.addToken(FluxLexer.TOKEN_TYPES.RIGHT_BRACKET);\n        break;\n      case ';':\n        this.addToken(FluxLexer.TOKEN_TYPES.SEMICOLON);\n        break;\n      case ',':\n        this.addToken(FluxLexer.TOKEN_TYPES.COMMA);\n        break;\n      case '.':\n        this.addToken(FluxLexer.TOKEN_TYPES.DOT);\n        break;\n      case ':':\n        this.addToken(FluxLexer.TOKEN_TYPES.COLON);\n        break;\n      case '?':\n        this.addToken(FluxLexer.TOKEN_TYPES.QUESTION);\n        break;\n      case '@':\n        this.addToken(FluxLexer.TOKEN_TYPES.AT);\n        break;\n      \n      case '+':\n        this.addToken(this.match('=') ? \n          FluxLexer.TOKEN_TYPES.PLUS_ASSIGN : \n          FluxLexer.TOKEN_TYPES.PLUS\n        );\n        break;\n      case '-':\n        this.addToken(this.match('=') ? \n          FluxLexer.TOKEN_TYPES.MINUS_ASSIGN : \n          FluxLexer.TOKEN_TYPES.MINUS\n        );\n        break;\n      case '*':\n        this.addToken(FluxLexer.TOKEN_TYPES.MULTIPLY);\n        break;\n      case '%':\n        this.addToken(FluxLexer.TOKEN_TYPES.MODULO);\n        break;\n      \n      case '!':\n        this.addToken(this.match('=') ? \n          FluxLexer.TOKEN_TYPES.NOT_EQUALS : \n          FluxLexer.TOKEN_TYPES.LOGICAL_NOT\n        );\n        break;\n      case '=':\n        this.addToken(this.match('=') ? \n          FluxLexer.TOKEN_TYPES.EQUALS : \n          FluxLexer.TOKEN_TYPES.ASSIGN\n        );\n        break;\n      case '<':\n        if (this.peek() === '/') {\n          this.advance(); // consume '/'\n          this.addToken(FluxLexer.TOKEN_TYPES.JSX_CLOSE);\n        } else if (this.match('=')) {\n          this.addToken(FluxLexer.TOKEN_TYPES.LESS_EQUAL);\n        } else {\n          this.addToken(FluxLexer.TOKEN_TYPES.JSX_OPEN);\n        }\n        break;\n      case '>':\n        this.addToken(this.match('=') ? \n          FluxLexer.TOKEN_TYPES.GREATER_EQUAL : \n          FluxLexer.TOKEN_TYPES.GREATER_THAN\n        );\n        break;\n      \n      case '&':\n        if (this.match('&')) {\n          this.addToken(FluxLexer.TOKEN_TYPES.LOGICAL_AND);\n        }\n        break;\n      case '|':\n        if (this.match('|')) {\n          this.addToken(FluxLexer.TOKEN_TYPES.LOGICAL_OR);\n        }\n        break;\n      \n      case '/':\n        if (this.match('/')) {\n          // Single line comment\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\n            this.advance();\n          }\n        } else if (this.match('*')) {\n          // Multi-line comment\n          this.blockComment();\n        } else if (this.match('>')) {\n          this.addToken(FluxLexer.TOKEN_TYPES.JSX_SELF_CLOSE);\n        } else {\n          this.addToken(FluxLexer.TOKEN_TYPES.DIVIDE);\n        }\n        break;\n      \n      case '\"':\n      case \"'\":\n        this.string(c);\n        break;\n      \n      default:\n        if (this.isDigit(c)) {\n          this.number();\n        } else if (this.isAlpha(c)) {\n          this.identifier();\n        } else {\n          this.addToken(FluxLexer.TOKEN_TYPES.UNKNOWN, c);\n        }\n        break;\n    }\n  }\n\n  identifier() {\n    while (this.isAlphaNumeric(this.peek())) {\n      this.advance();\n    }\n    \n    const text = this.source.substring(this.start, this.position);\n    const type = FluxLexer.KEYWORDS[text] || FluxLexer.TOKEN_TYPES.IDENTIFIER;\n    this.addToken(type, text);\n  }\n\n  number() {\n    while (this.isDigit(this.peek())) {\n      this.advance();\n    }\n    \n    // Look for decimal part\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      this.advance(); // consume '.'\n      while (this.isDigit(this.peek())) {\n        this.advance();\n      }\n    }\n    \n    const value = parseFloat(this.source.substring(this.start, this.position));\n    this.addToken(FluxLexer.TOKEN_TYPES.NUMBER, value);\n  }\n\n  string(quote) {\n    while (this.peek() !== quote && !this.isAtEnd()) {\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n    \n    if (this.isAtEnd()) {\n      throw new Error(`Unterminated string at line ${this.line}`);\n    }\n    \n    this.advance(); // closing quote\n    \n    const value = this.source.substring(this.start + 1, this.position - 1);\n    this.addToken(FluxLexer.TOKEN_TYPES.STRING, value);\n  }\n\n  blockComment() {\n    while (!this.isAtEnd()) {\n      if (this.peek() === '*' && this.peekNext() === '/') {\n        this.advance(); // consume '*'\n        this.advance(); // consume '/'\n        break;\n      }\n      if (this.peek() === '\\n') this.line++;\n      this.advance();\n    }\n  }\n\n  match(expected) {\n    if (this.isAtEnd()) return false;\n    if (this.source.charAt(this.position) !== expected) return false;\n    \n    this.position++;\n    this.column++;\n    return true;\n  }\n\n  peek() {\n    if (this.isAtEnd()) return '\\0';\n    return this.source.charAt(this.position);\n  }\n\n  peekNext() {\n    if (this.position + 1 >= this.source.length) return '\\0';\n    return this.source.charAt(this.position + 1);\n  }\n\n  isAlpha(c) {\n    return (c >= 'a' && c <= 'z') ||\n           (c >= 'A' && c <= 'Z') ||\n           c === '_';\n  }\n\n  isAlphaNumeric(c) {\n    return this.isAlpha(c) || this.isDigit(c);\n  }\n\n  isDigit(c) {\n    return c >= '0' && c <= '9';\n  }\n\n  isAtEnd() {\n    return this.position >= this.source.length;\n  }\n\n  advance() {\n    this.column++;\n    return this.source.charAt(this.position++);\n  }\n\n  addToken(type, literal = null) {\n    let text;\n    if (type === FluxLexer.TOKEN_TYPES.EOF) {\n      text = '';\n    } else {\n      text = this.source.substring(this.start, this.position);\n    }\n    this.tokens.push({\n      type,\n      lexeme: text,\n      literal,\n      line: this.line,\n      column: this.column - text.length\n    });\n  }\n}", "// flux-core/src/ast/nodes.js\n// Abstract Syntax Tree node definitions for Flux language\n\nexport class ASTNode {\n  constructor(type, location) {\n    this.type = type;\n    this.location = location;\n  }\n}\n\n// Program root\nexport class Program extends ASTNode {\n  constructor(body, location) {\n    super('Program', location);\n    this.body = body; // Array of top-level statements\n  }\n}\n\n// Imports and Exports\nexport class ImportDeclaration extends ASTNode {\n  constructor(specifiers, source, location) {\n    super('ImportDeclaration', location);\n    this.specifiers = specifiers;\n    this.source = source;\n  }\n}\n\nexport class ImportSpecifier extends ASTNode {\n  constructor(imported, local, location) {\n    super('ImportSpecifier', location);\n    this.imported = imported;\n    this.local = local;\n  }\n}\n\nexport class ExportDeclaration extends ASTNode {\n  constructor(declaration, location) {\n    super('ExportDeclaration', location);\n    this.declaration = declaration;\n  }\n}\n\n// Component Declaration\nexport class ComponentDeclaration extends ASTNode {\n  constructor(name, decorators, body, location) {\n    super('ComponentDeclaration', location);\n    this.name = name;\n    this.decorators = decorators || [];\n    this.body = body;\n    this.state = [];\n    this.props = [];\n    this.methods = [];\n    this.effects = [];\n    this.computed = [];\n    this.render = null;\n    this.lifecycle = [];\n    \n    // Organize body items\n    this.organizeBody();\n  }\n  \n  organizeBody() {\n    for (const item of this.body) {\n      switch (item.type) {\n        case 'StateDeclaration':\n          this.state.push(item);\n          break;\n        case 'PropDeclaration':\n          this.props.push(item);\n          break;\n        case 'MethodDeclaration':\n          this.methods.push(item);\n          break;\n        case 'EffectDeclaration':\n          this.effects.push(item);\n          break;\n        case 'ComputedDeclaration':\n          this.computed.push(item);\n          break;\n        case 'RenderDeclaration':\n          this.render = item;\n          break;\n        case 'LifecycleDeclaration':\n          this.lifecycle.push(item);\n          break;\n      }\n    }\n  }\n}\n\n// Store Declaration\nexport class StoreDeclaration extends ASTNode {\n  constructor(name, body, location) {\n    super('StoreDeclaration', location);\n    this.name = name;\n    this.body = body;\n    this.state = [];\n    this.actions = [];\n    this.computed = [];\n    \n    this.organizeBody();\n  }\n  \n  organizeBody() {\n    for (const item of this.body) {\n      switch (item.type) {\n        case 'StateDeclaration':\n          this.state.push(item);\n          break;\n        case 'ActionDeclaration':\n          this.actions.push(item);\n          break;\n        case 'ComputedDeclaration':\n          this.computed.push(item);\n          break;\n      }\n    }\n  }\n}\n\n// Declarations\nexport class StateDeclaration extends ASTNode {\n  constructor(name, initialValue, typeAnnotation, location) {\n    super('StateDeclaration', location);\n    this.name = name;\n    this.initialValue = initialValue;\n    this.typeAnnotation = typeAnnotation;\n  }\n}\n\nexport class PropDeclaration extends ASTNode {\n  constructor(name, typeAnnotation, defaultValue, location) {\n    super('PropDeclaration', location);\n    this.name = name;\n    this.typeAnnotation = typeAnnotation;\n    this.defaultValue = defaultValue;\n  }\n}\n\nexport class MethodDeclaration extends ASTNode {\n  constructor(name, parameters, body, isAsync, location) {\n    super('MethodDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\nexport class ActionDeclaration extends ASTNode {\n  constructor(name, parameters, body, isAsync, location) {\n    super('ActionDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\nexport class EffectDeclaration extends ASTNode {\n  constructor(dependencies, body, location) {\n    super('EffectDeclaration', location);\n    this.dependencies = dependencies;\n    this.body = body;\n  }\n}\n\nexport class ComputedDeclaration extends ASTNode {\n  constructor(name, body, location) {\n    super('ComputedDeclaration', location);\n    this.name = name;\n    this.body = body;\n  }\n}\n\nexport class RenderDeclaration extends ASTNode {\n  constructor(body, location) {\n    super('RenderDeclaration', location);\n    this.body = body;\n  }\n}\n\nexport class LifecycleDeclaration extends ASTNode {\n  constructor(phase, body, isAsync, location) {\n    super('LifecycleDeclaration', location);\n    this.phase = phase; // 'mounted', 'updated', 'unmounted', etc.\n    this.body = body;\n    this.isAsync = isAsync;\n  }\n}\n\n// Decorators\nexport class Decorator extends ASTNode {\n  constructor(name, arguments_, location) {\n    super('Decorator', location);\n    this.name = name;\n    this.arguments = arguments_ || [];\n  }\n}\n\n// Expressions\nexport class BinaryExpression extends ASTNode {\n  constructor(left, operator, right, location) {\n    super('BinaryExpression', location);\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n}\n\nexport class UnaryExpression extends ASTNode {\n  constructor(operator, operand, location) {\n    super('UnaryExpression', location);\n    this.operator = operator;\n    this.operand = operand;\n  }\n}\n\nexport class AssignmentExpression extends ASTNode {\n  constructor(left, operator, right, location) {\n    super('AssignmentExpression', location);\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n}\n\nexport class CallExpression extends ASTNode {\n  constructor(callee, arguments_, location) {\n    super('CallExpression', location);\n    this.callee = callee;\n    this.arguments = arguments_;\n  }\n}\n\nexport class MemberExpression extends ASTNode {\n  constructor(object, property, computed, location) {\n    super('MemberExpression', location);\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n}\n\nexport class ConditionalExpression extends ASTNode {\n  constructor(test, consequent, alternate, location) {\n    super('ConditionalExpression', location);\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n}\n\nexport class ArrayExpression extends ASTNode {\n  constructor(elements, location) {\n    super('ArrayExpression', location);\n    this.elements = elements;\n  }\n}\n\nexport class ObjectExpression extends ASTNode {\n  constructor(properties, location) {\n    super('ObjectExpression', location);\n    this.properties = properties;\n  }\n}\n\nexport class Property extends ASTNode {\n  constructor(key, value, kind, location) {\n    super('Property', location);\n    this.key = key;\n    this.value = value;\n    this.kind = kind || 'init';\n  }\n}\n\n// Literals\nexport class Literal extends ASTNode {\n  constructor(value, location) {\n    super('Literal', location);\n    this.value = value;\n  }\n}\n\nexport class Identifier extends ASTNode {\n  constructor(name, location) {\n    super('Identifier', location);\n    this.name = name;\n  }\n}\n\n// JSX-like Nodes\nexport class JSXElement extends ASTNode {\n  constructor(openingElement, children, closingElement, location) {\n    super('JSXElement', location);\n    this.openingElement = openingElement;\n    this.children = children;\n    this.closingElement = closingElement;\n    this.selfClosing = !closingElement;\n  }\n}\n\nexport class JSXOpeningElement extends ASTNode {\n  constructor(name, attributes, selfClosing, location) {\n    super('JSXOpeningElement', location);\n    this.name = name;\n    this.attributes = attributes;\n    this.selfClosing = selfClosing;\n  }\n}\n\nexport class JSXClosingElement extends ASTNode {\n  constructor(name, location) {\n    super('JSXClosingElement', location);\n    this.name = name;\n  }\n}\n\nexport class JSXAttribute extends ASTNode {\n  constructor(name, value, location) {\n    super('JSXAttribute', location);\n    this.name = name;\n    this.value = value;\n  }\n}\n\nexport class JSXExpressionContainer extends ASTNode {\n  constructor(expression, location) {\n    super('JSXExpressionContainer', location);\n    this.expression = expression;\n  }\n}\n\nexport class JSXText extends ASTNode {\n  constructor(value, location) {\n    super('JSXText', location);\n    this.value = value;\n  }\n}\n\n// Statements\nexport class ExpressionStatement extends ASTNode {\n  constructor(expression, location) {\n    super('ExpressionStatement', location);\n    this.expression = expression;\n  }\n}\n\nexport class BlockStatement extends ASTNode {\n  constructor(body, location) {\n    super('BlockStatement', location);\n    this.body = body;\n  }\n}\n\nexport class IfStatement extends ASTNode {\n  constructor(test, consequent, alternate, location) {\n    super('IfStatement', location);\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n}\n\nexport class WhileStatement extends ASTNode {\n  constructor(test, body, location) {\n    super('WhileStatement', location);\n    this.test = test;\n    this.body = body;\n  }\n}\n\nexport class ForStatement extends ASTNode {\n  constructor(init, test, update, body, location) {\n    super('ForStatement', location);\n    this.init = init;\n    this.test = test;\n    this.update = update;\n    this.body = body;\n  }\n}\n\nexport class ReturnStatement extends ASTNode {\n  constructor(argument, location) {\n    super('ReturnStatement', location);\n    this.argument = argument;\n  }\n}\n\nexport class TryStatement extends ASTNode {\n  constructor(block, handler, finalizer, location) {\n    super('TryStatement', location);\n    this.block = block;\n    this.handler = handler;\n    this.finalizer = finalizer;\n  }\n}\n\nexport class CatchClause extends ASTNode {\n  constructor(param, body, location) {\n    super('CatchClause', location);\n    this.param = param;\n    this.body = body;\n  }\n}\n\nexport class ThrowStatement extends ASTNode {\n  constructor(argument, location) {\n    super('ThrowStatement', location);\n    this.argument = argument;\n  }\n}\n\nexport class VariableDeclaration extends ASTNode {\n  constructor(declarations, kind, location) {\n    super('VariableDeclaration', location);\n    this.declarations = declarations;\n    this.kind = kind; // 'var', 'let', 'const'\n  }\n}\n\nexport class VariableDeclarator extends ASTNode {\n  constructor(id, init, location) {\n    super('VariableDeclarator', location);\n    this.id = id;\n    this.init = init;\n  }\n}\n\n// Route specific nodes\nexport class RouteDeclaration extends ASTNode {\n  constructor(path, component, guards, loaders, meta, location) {\n    super('RouteDeclaration', location);\n    this.path = path;\n    this.component = component;\n    this.guards = guards || [];\n    this.loaders = loaders || [];\n    this.meta = meta;\n  }\n}\n\nexport class GuardDeclaration extends ASTNode {\n  constructor(name, parameters, body, location) {\n    super('GuardDeclaration', location);\n    this.name = name;\n    this.parameters = parameters;\n    this.body = body;\n  }\n}\n\n// Type annotations\nexport class TypeAnnotation extends ASTNode {\n  constructor(typeAnnotation, location) {\n    super('TypeAnnotation', location);\n    this.typeAnnotation = typeAnnotation;\n  }\n}\n\nexport class TSStringKeyword extends ASTNode {\n  constructor(location) {\n    super('TSStringKeyword', location);\n  }\n}\n\nexport class TSNumberKeyword extends ASTNode {\n  constructor(location) {\n    super('TSNumberKeyword', location);\n  }\n}\n\nexport class TSBooleanKeyword extends ASTNode {\n  constructor(location) {\n    super('TSBooleanKeyword', location);\n  }\n}\n\nexport class TSArrayType extends ASTNode {\n  constructor(elementType, location) {\n    super('TSArrayType', location);\n    this.elementType = elementType;\n  }\n}\n\nexport class TSUnionType extends ASTNode {\n  constructor(types, location) {\n    super('TSUnionType', location);\n    this.types = types;\n  }\n}\n\n// Utility function to create location object\nexport function createLocation(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: { line: startLine, column: startColumn },\n    end: { line: endLine, column: endColumn }\n  };\n}", "// flux-core/src/compiler/parser.js\n// Recursive descent parser for Flux language\n\nimport { FluxLexer } from './lexer.js';\nimport * as AST from '../ast/nodes.js';\n\nexport class FluxParser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.errors = [];\n  }\n\n  static parse(source) {\n    const lexer = new FluxLexer(source);\n    const tokens = lexer.tokenize();\n    const parser = new FluxParser(tokens);\n    return parser.program();\n  }\n\n  program() {\n    const body = [];\n    \n    while (!this.isAtEnd()) {\n      // Skip newlines at top level\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n      \n      const stmt = this.topLevelStatement();\n      if (stmt) body.push(stmt);\n    }\n    \n    return new AST.Program(body, this.getCurrentLocation());\n  }\n\n  topLevelStatement() {\n    try {\n      if (this.match('IMPORT')) {\n        return this.importDeclaration();\n      }\n      \n      if (this.match('EXPORT')) {\n        return this.exportDeclaration();\n      }\n      \n      // Handle decorators\n      const decorators = [];\n      while (this.check('AT')) {\n        decorators.push(this.decorator());\n      }\n      \n      if (this.match('COMPONENT')) {\n        return this.componentDeclaration(decorators);\n      }\n      \n      if (this.match('STORE')) {\n        return this.storeDeclaration(decorators);\n      }\n      \n      if (this.match('GUARD')) {\n        return this.guardDeclaration(decorators);\n      }\n      \n      return this.statement();\n    } catch (error) {\n      this.synchronize();\n      throw error;\n    }\n  }\n\n  importDeclaration() {\n    const specifiers = [];\n    \n    if (this.check('LEFT_BRACE')) {\n      // Named imports: import { name1, name2 } from 'module'\n      this.consume('LEFT_BRACE', 'Expected \"{\"');\n      \n      do {\n        const imported = this.consume('IDENTIFIER', 'Expected identifier');\n        let local = imported;\n        \n        if (this.match('AS')) {\n          local = this.consume('IDENTIFIER', 'Expected identifier after \"as\"');\n        }\n        \n        specifiers.push(new AST.ImportSpecifier(\n          new AST.Identifier(imported.lexeme),\n          new AST.Identifier(local.lexeme)\n        ));\n      } while (this.match('COMMA'));\n      \n      this.consume('RIGHT_BRACE', 'Expected \"}\"');\n    } else {\n      // Default import: import name from 'module'\n      const name = this.consume('IDENTIFIER', 'Expected identifier');\n      specifiers.push(new AST.ImportSpecifier(\n        new AST.Identifier('default'),\n        new AST.Identifier(name.lexeme)\n      ));\n    }\n    \n    this.consume('FROM', 'Expected \"from\"');\n    const source = this.consume('STRING', 'Expected module path');\n    \n    return new AST.ImportDeclaration(\n      specifiers,\n      new AST.Literal(source.literal),\n      this.getCurrentLocation()\n    );\n  }\n\n  exportDeclaration() {\n    const declaration = this.topLevelStatement();\n    return new AST.ExportDeclaration(declaration, this.getCurrentLocation());\n  }\n\n  decorator() {\n    this.consume('AT', 'Expected \"@\"');\n    const name = this.consume('IDENTIFIER', 'Expected decorator name');\n    \n    let args = [];\n    if (this.match('LEFT_PAREN')) {\n      args = this.argumentList();\n      this.consume('RIGHT_PAREN', 'Expected \")\"');\n    }\n    \n    return new AST.Decorator(\n      new AST.Identifier(name.lexeme),\n      args,\n      this.getCurrentLocation()\n    );\n  }\n\n  componentDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected component name');\n    \n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n    \n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n      \n      const member = this.componentMember();\n      if (member) body.push(member);\n    }\n    \n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n    \n    return new AST.ComponentDeclaration(\n      new AST.Identifier(name.lexeme),\n      decorators,\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  componentMember() {\n    if (this.match('STATE')) {\n      return this.stateDeclaration();\n    }\n    \n    if (this.match('PROP')) {\n      return this.propDeclaration();\n    }\n    \n    if (this.match('METHOD')) {\n      return this.methodDeclaration();\n    }\n    \n    if (this.match('EFFECT')) {\n      return this.effectDeclaration();\n    }\n    \n    if (this.match('COMPUTED')) {\n      return this.computedDeclaration();\n    }\n    \n    if (this.match('RENDER')) {\n      return this.renderDeclaration();\n    }\n    \n    if (this.match('LIFECYCLE')) {\n      return this.lifecycleDeclaration();\n    }\n    \n    return this.statement();\n  }\n\n  stateDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected state variable name');\n    \n    let typeAnnotation = null;\n    if (this.match('COLON')) {\n      typeAnnotation = this.typeAnnotation();\n    }\n    \n    let initialValue = null;\n    if (this.match('ASSIGN')) {\n      initialValue = this.expression();\n    }\n    \n    return new AST.StateDeclaration(\n      new AST.Identifier(name.lexeme),\n      initialValue,\n      typeAnnotation,\n      this.getCurrentLocation()\n    );\n  }\n\n  propDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected prop name');\n    \n    let typeAnnotation = null;\n    if (this.match('COLON')) {\n      typeAnnotation = this.typeAnnotation();\n    }\n    \n    let defaultValue = null;\n    if (this.match('ASSIGN')) {\n      defaultValue = this.expression();\n    }\n    \n    return new AST.PropDeclaration(\n      new AST.Identifier(name.lexeme),\n      typeAnnotation,\n      defaultValue,\n      this.getCurrentLocation()\n    );\n  }\n\n  methodDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const name = this.consume('IDENTIFIER', 'Expected method name');\n    \n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n    \n    const body = this.blockStatement();\n    \n    return new AST.MethodDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      isAsync,\n      this.getCurrentLocation()\n    );\n  }\n\n  effectDeclaration() {\n    let dependencies = [];\n    \n    if (this.match('ON')) {\n      // effect on dependency1, dependency2 { ... }\n      dependencies.push(this.expression());\n      \n      while (this.match('COMMA')) {\n        dependencies.push(this.expression());\n      }\n    }\n    \n    const body = this.blockStatement();\n    \n    return new AST.EffectDeclaration(\n      dependencies,\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  computedDeclaration() {\n    const name = this.consume('IDENTIFIER', 'Expected computed property name');\n    \n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n    \n    const body = this.blockStatement();\n    \n    return new AST.ComputedDeclaration(\n      new AST.Identifier(name.lexeme),\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  renderDeclaration() {\n    const body = this.blockStatement();\n    \n    return new AST.RenderDeclaration(\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  lifecycleDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const phase = this.consume('IDENTIFIER', 'Expected lifecycle phase');\n    \n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n    \n    const body = this.blockStatement();\n    \n    return new AST.LifecycleDeclaration(\n      phase.lexeme,\n      body,\n      isAsync,\n      this.getCurrentLocation()\n    );\n  }\n\n  storeDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected store name');\n    \n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n    \n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n      \n      const member = this.storeMember();\n      if (member) body.push(member);\n    }\n    \n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n    \n    return new AST.StoreDeclaration(\n      new AST.Identifier(name.lexeme),\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  storeMember() {\n    if (this.match('STATE')) {\n      return this.stateDeclaration();\n    }\n    \n    if (this.match('ACTION')) {\n      return this.actionDeclaration();\n    }\n    \n    if (this.match('COMPUTED')) {\n      return this.computedDeclaration();\n    }\n    \n    return this.statement();\n  }\n\n  actionDeclaration() {\n    const isAsync = this.match('ASYNC');\n    const name = this.consume('IDENTIFIER', 'Expected action name');\n    \n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n    \n    const body = this.blockStatement();\n    \n    return new AST.ActionDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      isAsync,\n      this.getCurrentLocation()\n    );\n  }\n\n  guardDeclaration(decorators = []) {\n    const name = this.consume('IDENTIFIER', 'Expected guard name');\n    \n    this.consume('LEFT_PAREN', 'Expected \"(\"');\n    const parameters = this.parameterList();\n    this.consume('RIGHT_PAREN', 'Expected \")\"');\n    \n    const body = this.blockStatement();\n    \n    return new AST.GuardDeclaration(\n      new AST.Identifier(name.lexeme),\n      parameters,\n      body,\n      this.getCurrentLocation()\n    );\n  }\n\n  // Statements\n  statement() {\n    if (this.match('IF')) {\n      return this.ifStatement();\n    }\n    \n    if (this.match('WHILE')) {\n      return this.whileStatement();\n    }\n    \n    if (this.match('FOR')) {\n      return this.forStatement();\n    }\n    \n    if (this.match('RETURN')) {\n      return this.returnStatement();\n    }\n    \n    if (this.match('TRY')) {\n      return this.tryStatement();\n    }\n    \n    if (this.match('LEFT_BRACE')) {\n      return this.blockStatement();\n    }\n    \n    return this.expressionStatement();\n  }\n\n  ifStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"if\"');\n    const test = this.expression();\n    this.consume('RIGHT_PAREN', 'Expected \")\" after if condition');\n    \n    const consequent = this.statement();\n    let alternate = null;\n    \n    if (this.match('ELSE')) {\n      alternate = this.statement();\n    }\n    \n    return new AST.IfStatement(test, consequent, alternate, this.getCurrentLocation());\n  }\n\n  whileStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"while\"');\n    const test = this.expression();\n    this.consume('RIGHT_PAREN', 'Expected \")\" after while condition');\n    \n    const body = this.statement();\n    \n    return new AST.WhileStatement(test, body, this.getCurrentLocation());\n  }\n\n  forStatement() {\n    this.consume('LEFT_PAREN', 'Expected \"(\" after \"for\"');\n    \n    let init = null;\n    if (!this.check('SEMICOLON')) {\n      init = this.expression();\n    }\n    this.consume('SEMICOLON', 'Expected \";\" after for loop initializer');\n    \n    let test = null;\n    if (!this.check('SEMICOLON')) {\n      test = this.expression();\n    }\n    this.consume('SEMICOLON', 'Expected \";\" after for loop condition');\n    \n    let update = null;\n    if (!this.check('RIGHT_PAREN')) {\n      update = this.expression();\n    }\n    this.consume('RIGHT_PAREN', 'Expected \")\" after for clauses');\n    \n    const body = this.statement();\n    \n    return new AST.ForStatement(init, test, update, body, this.getCurrentLocation());\n  }\n\n  returnStatement() {\n    let argument = null;\n    \n    if (!this.check('NEWLINE') && !this.check('SEMICOLON')) {\n      argument = this.expression();\n    }\n    \n    return new AST.ReturnStatement(argument, this.getCurrentLocation());\n  }\n\n  tryStatement() {\n    const block = this.blockStatement();\n    \n    let handler = null;\n    if (this.match('CATCH')) {\n      this.consume('LEFT_PAREN', 'Expected \"(\" after \"catch\"');\n      const param = this.consume('IDENTIFIER', 'Expected catch parameter');\n      this.consume('RIGHT_PAREN', 'Expected \")\" after catch parameter');\n      \n      const body = this.blockStatement();\n      handler = new AST.CatchClause(\n        new AST.Identifier(param.lexeme),\n        body,\n        this.getCurrentLocation()\n      );\n    }\n    \n    let finalizer = null;\n    if (this.match('FINALLY')) {\n      finalizer = this.blockStatement();\n    }\n    \n    return new AST.TryStatement(block, handler, finalizer, this.getCurrentLocation());\n  }\n\n  blockStatement() {\n    this.consume('LEFT_BRACE', 'Expected \"{\"');\n    \n    const body = [];\n    while (!this.check('RIGHT_BRACE') && !this.isAtEnd()) {\n      if (this.check('NEWLINE')) {\n        this.advance();\n        continue;\n      }\n      \n      body.push(this.statement());\n    }\n    \n    this.consume('RIGHT_BRACE', 'Expected \"}\"');\n    \n    return new AST.BlockStatement(body, this.getCurrentLocation());\n  }\n\n  expressionStatement() {\n    const expr = this.expression();\n    return new AST.ExpressionStatement(expr, this.getCurrentLocation());\n  }\n\n  // Expressions\n  expression() {\n    return this.assignment();\n  }\n\n  assignment() {\n    const expr = this.ternary();\n    \n    if (this.match('ASSIGN', 'PLUS_ASSIGN', 'MINUS_ASSIGN')) {\n      const operator = this.previous();\n      const value = this.assignment();\n      \n      if (expr.type !== 'Identifier') {\n        throw new Error('Invalid assignment target');\n      }\n      \n      return new AST.AssignmentExpression(\n        expr,\n        operator.lexeme,\n        value,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  ternary() {\n    let expr = this.logicalOr();\n    \n    if (this.match('QUESTION')) {\n      const consequent = this.expression();\n      this.consume('COLON', 'Expected \":\" in ternary expression');\n      const alternate = this.ternary();\n      \n      expr = new AST.ConditionalExpression(\n        expr,\n        consequent,\n        alternate,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  logicalOr() {\n    let expr = this.logicalAnd();\n    \n    while (this.match('LOGICAL_OR')) {\n      const operator = this.previous();\n      const right = this.logicalAnd();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  logicalAnd() {\n    let expr = this.equality();\n    \n    while (this.match('LOGICAL_AND')) {\n      const operator = this.previous();\n      const right = this.equality();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  equality() {\n    let expr = this.comparison();\n    \n    while (this.match('EQUALS', 'NOT_EQUALS')) {\n      const operator = this.previous();\n      const right = this.comparison();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  comparison() {\n    let expr = this.addition();\n    \n    while (this.match('GREATER_THAN', 'GREATER_EQUAL', 'LESS_THAN', 'LESS_EQUAL')) {\n      const operator = this.previous();\n      const right = this.addition();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  addition() {\n    let expr = this.multiplication();\n    \n    while (this.match('PLUS', 'MINUS')) {\n      const operator = this.previous();\n      const right = this.multiplication();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  multiplication() {\n    let expr = this.unary();\n    \n    while (this.match('MULTIPLY', 'DIVIDE', 'MODULO')) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new AST.BinaryExpression(\n        expr,\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return expr;\n  }\n\n  unary() {\n    if (this.match('LOGICAL_NOT', 'MINUS', 'PLUS')) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new AST.UnaryExpression(\n        operator.lexeme,\n        right,\n        this.getCurrentLocation()\n      );\n    }\n    \n    return this.postfix();\n  }\n\n  postfix() {\n    let expr = this.primary();\n    \n    while (true) {\n      if (this.match('LEFT_PAREN')) {\n        // Function call\n        const args = this.argumentList();\n        this.consume('RIGHT_PAREN', 'Expected \")\" after arguments');\n        \n        expr = new AST.CallExpression(\n          expr,\n          args,\n          this.getCurrentLocation()\n        );\n      } else if (this.match('LEFT_BRACKET')) {\n        // Array access\n        const index = this.expression();\n        this.consume('RIGHT_BRACKET', 'Expected \"]\" after array index');\n        \n        expr = new AST.MemberExpression(\n          expr,\n          index,\n          true, // computed\n          this.getCurrentLocation()\n        );\n      } else if (this.match('DOT')) {\n        // Property access\n        const property = this.consume('IDENTIFIER', 'Expected property name');\n        \n        expr = new AST.MemberExpression(\n          expr,\n          new AST.Identifier(property.lexeme),\n          false, // not computed\n          this.getCurrentLocation()\n        );\n      } else {\n        break;\n      }\n    }\n    \n    return expr;\n  }\n\n  primary() {\n    if (this.match('BOOLEAN')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n    \n    if (this.match('NUMBER')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n    \n    if (this.match('STRING')) {\n      return new AST.Literal(this.previous().literal, this.getCurrentLocation());\n    }\n    \n    if (this.match('IDENTIFIER')) {\n      return new AST.Identifier(this.previous().lexeme, this.getCurrentLocation());\n    }\n    \n    if (this.match('LEFT_PAREN')) {\n      const expr = this.expression();\n      this.consume('RIGHT_PAREN', 'Expected \")\" after expression');\n      return expr;\n    }\n    \n    if (this.match('LEFT_BRACKET')) {\n      // Array literal\n      const elements = [];\n      \n      if (!this.check('RIGHT_BRACKET')) {\n        do {\n          elements.push(this.expression());\n        } while (this.match('COMMA'));\n      }\n      \n      this.consume('RIGHT_BRACKET', 'Expected \"]\" after array elements');\n      \n      return new AST.ArrayExpression(elements, this.getCurrentLocation());\n    }\n    \n    if (this.match('LEFT_BRACE')) {\n      // Object literal\n      const properties = [];\n      \n      if (!this.check('RIGHT_BRACE')) {\n        do {\n          if (this.check('NEWLINE')) {\n            this.advance();\n            continue;\n          }\n          \n          let key;\n          if (this.match('STRING')) {\n            key = new AST.Literal(this.previous().literal);\n          } else {\n            const name = this.consume('IDENTIFIER', 'Expected property name');\n            key = new AST.Identifier(name.lexeme);\n          }\n          \n          this.consume('COLON', 'Expected \":\" after property name');\n          const value = this.expression();\n          \n          properties.push(new AST.Property(key, value, 'init', this.getCurrentLocation()));\n        } while (this.match('COMMA'));\n      }\n      \n      this.consume('RIGHT_BRACE', 'Expected \"}\" after object properties');\n      \n      return new AST.ObjectExpression(properties, this.getCurrentLocation());\n    }\n    \n    // JSX Element\n    if (this.check('JSX_OPEN')) {\n      return this.jsxElement();\n    }\n    \n    throw new Error(`Unexpected token: ${this.peek().lexeme} at line ${this.peek().line}`);\n  }\n\n  jsxElement() {\n    this.consume('JSX_OPEN', 'Expected \"<\"');\n    \n    // Element name\n    const name = this.consume('IDENTIFIER', 'Expected element name');\n    const elementName = new AST.Identifier(name.lexeme);\n    \n    // Attributes\n    const attributes = [];\n    while (!this.check('GREATER_THAN') && !this.check('JSX_SELF_CLOSE') && !this.isAtEnd()) {\n      attributes.push(this.jsxAttribute());\n    }\n    \n    // Self-closing tag\n    if (this.match('JSX_SELF_CLOSE')) {\n      return new AST.JSXElement(\n        new AST.JSXOpeningElement(elementName, attributes, true),\n        [],\n        null,\n        this.getCurrentLocation()\n      );\n    }\n    \n    this.consume('GREATER_THAN', 'Expected \">\" after opening tag');\n    \n    // Children\n    const children = [];\n    while (!this.check('JSX_CLOSE') && !this.isAtEnd()) {\n      if (this.check('JSX_OPEN') && this.peekNext().type === 'IDENTIFIER') {\n        // Nested element\n        children.push(this.jsxElement());\n      } else if (this.check('LEFT_BRACE')) {\n        // Expression\n        this.advance(); // consume '{'\n        const expr = this.expression();\n        this.consume('RIGHT_BRACE', 'Expected \"}\" after JSX expression');\n        children.push(new AST.JSXExpressionContainer(expr));\n      } else {\n        // Text content\n        let text = '';\n        while (!this.check('JSX_OPEN') && !this.check('JSX_CLOSE') && !this.check('LEFT_BRACE') && !this.isAtEnd()) {\n          text += this.advance().lexeme;\n        }\n        if (text.trim()) {\n          children.push(new AST.JSXText(text.trim()));\n        }\n      }\n    }\n    \n    // Closing tag\n    this.consume('JSX_CLOSE', 'Expected closing tag');\n    const closingName = this.consume('IDENTIFIER', 'Expected closing tag name');\n    this.consume('GREATER_THAN', 'Expected \">\" after closing tag');\n    \n    if (closingName.lexeme !== name.lexeme) {\n      throw new Error(`Mismatched JSX tags: ${name.lexeme} and ${closingName.lexeme}`);\n    }\n    \n    return new AST.JSXElement(\n      new AST.JSXOpeningElement(elementName, attributes, false),\n      children,\n      new AST.JSXClosingElement(new AST.Identifier(closingName.lexeme)),\n      this.getCurrentLocation()\n    );\n  }\n\n  jsxAttribute() {\n    let name;\n    if (this.check('AT')) {\n      this.advance(); // consume '@'\n      const eventName = this.consume('IDENTIFIER', 'Expected event name after @');\n      name = new AST.Identifier('@' + eventName.lexeme);\n    } else {\n      const attrName = this.consume('IDENTIFIER', 'Expected attribute name');\n      name = new AST.Identifier(attrName.lexeme);\n    }\n    \n    if (this.match('ASSIGN')) {\n      let value;\n      if (this.match('STRING')) {\n        value = new AST.Literal(this.previous().literal);\n      } else if (this.match('LEFT_BRACE')) {\n        const expr = this.expression();\n        this.consume('RIGHT_BRACE', 'Expected \"}\" after JSX expression');\n        value = new AST.JSXExpressionContainer(expr);\n      } else {\n        throw new Error('Expected attribute value');\n      }\n      \n      return new AST.JSXAttribute(\n        new AST.Identifier(name.lexeme),\n        value,\n        this.getCurrentLocation()\n      );\n    }\n    \n    // Boolean attribute\n    return new AST.JSXAttribute(\n      new AST.Identifier(name.lexeme),\n      new AST.Literal(true),\n      this.getCurrentLocation()\n    );\n  }\n\n  parameterList() {\n    const parameters = [];\n    \n    if (!this.check('RIGHT_PAREN')) {\n      do {\n        const name = this.consume('IDENTIFIER', 'Expected parameter name');\n        \n        let typeAnnotation = null;\n        if (this.match('COLON')) {\n          typeAnnotation = this.typeAnnotation();\n        }\n        \n        let defaultValue = null;\n        if (this.match('ASSIGN')) {\n          defaultValue = this.expression();\n        }\n        \n        parameters.push({\n          name: new AST.Identifier(name.lexeme),\n          typeAnnotation,\n          defaultValue\n        });\n      } while (this.match('COMMA'));\n    }\n    \n    return parameters;\n  }\n\n  argumentList() {\n    const args = [];\n    \n    if (!this.check('RIGHT_PAREN')) {\n      do {\n        args.push(this.expression());\n      } while (this.match('COMMA'));\n    }\n    \n    return args;\n  }\n\n  typeAnnotation() {\n    if (this.match('IDENTIFIER')) {\n      const typeName = this.previous().lexeme;\n      \n      switch (typeName) {\n        case 'string':\n          return new AST.TSStringKeyword();\n        case 'number':\n          return new AST.TSNumberKeyword();\n        case 'boolean':\n          return new AST.TSBooleanKeyword();\n        default:\n          return new AST.Identifier(typeName);\n      }\n    }\n    \n    throw new Error('Expected type annotation');\n  }\n\n  // Utility methods\n  match(...types) {\n    for (const type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  check(type) {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  advance() {\n    if (!this.isAtEnd()) this.current++;\n    return this.previous();\n  }\n\n  isAtEnd() {\n    return this.peek().type === 'EOF';\n  }\n\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  peekNext() {\n    if (this.current + 1 >= this.tokens.length) {\n      return this.tokens[this.tokens.length - 1]; // EOF\n    }\n    return this.tokens[this.current + 1];\n  }\n\n  previous() {\n    return this.tokens[this.current - 1];\n  }\n\n  consume(type, message) {\n    if (this.check(type)) return this.advance();\n    \n    const current = this.peek();\n    throw new Error(`${message}. Got ${current.type} \"${current.lexeme}\" at line ${current.line}`);\n  }\n\n  synchronize() {\n    this.advance();\n    \n    while (!this.isAtEnd()) {\n      if (this.previous().type === 'NEWLINE') return;\n      \n      switch (this.peek().type) {\n        case 'COMPONENT':\n        case 'STORE':\n        case 'GUARD':\n        case 'IF':\n        case 'FOR':\n        case 'WHILE':\n        case 'RETURN':\n          return;\n      }\n      \n      this.advance();\n    }\n  }\n\n  getCurrentLocation() {\n    const token = this.peek();\n    return AST.createLocation(token.line, token.column, token.line, token.column);\n  }\n}", "// flux-core/src/compiler/codegen.js\n// Code generator that converts Flux AST to optimized JavaScript\n\nimport * as AST from '../ast/nodes.js';\n\nexport class FluxCodeGenerator {\n  constructor(options = {}) {\n    this.options = {\n      target: 'modern', // 'modern' or 'legacy'\n      minify: false,\n      sourceMaps: true,\n      optimizations: true,\n      ...options\n    };\n    this.indent = 0;\n    this.output = [];\n    this.imports = new Set();\n    this.componentCount = 0;\n    this.storeCount = 0;\n    this.errors = [];\n  }\n\n  generate(ast) {\n    this.output = [];\n    this.indent = 0;\n    \n    // Add runtime imports\n    this.addLine(\"import { FluxRuntime, Component, Store, createReactiveState, createEffect, createComputed } from '@flux/runtime';\");\n    this.addLine(\"import { createElement, Fragment } from '@flux/jsx';\");\n    this.addLine(\"\");\n    \n    this.visit(ast);\n    \n    return this.output.join('\\n');\n  }\n\n  visit(node) {\n    const methodName = `visit${node.type}`;\n    if (this[methodName]) {\n      return this[methodName](node);\n    }\n    \n    console.warn(`No visitor method for ${node.type}`);\n    return '';\n  }\n\n  visitProgram(node) {\n    for (const statement of node.body) {\n      this.visit(statement);\n      this.addLine(\"\");\n    }\n  }\n\n  visitImportDeclaration(node) {\n    const specifiers = node.specifiers.map(spec => {\n      if (spec.imported.name === 'default') {\n        return spec.local.name;\n      }\n      return spec.imported.name === spec.local.name \n        ? spec.imported.name \n        : `${spec.imported.name} as ${spec.local.name}`;\n    }).join(', ');\n    \n    this.addLine(`import { ${specifiers} } from ${JSON.stringify(node.source.value)};`);\n  }\n\n  visitExportDeclaration(node) {\n    this.add(\"export \");\n    this.visit(node.declaration);\n  }\n\n  visitComponentDeclaration(node) {\n    const componentName = node.name.name;\n    this.componentCount++;\n    \n    this.addLine(`class ${componentName} extends Component {`);\n    this.indent++;\n    \n    // Constructor\n    this.addLine(\"constructor(props = {}) {\");\n    this.indent++;\n    this.addLine(\"super(props);\");\n    this.addLine(\"\");\n    \n    // Initialize state\n    if (node.state.length > 0) {\n      this.addLine(\"// Initialize state\");\n      for (const stateDecl of node.state) {\n        const name = stateDecl.name.name;\n        const initialValue = stateDecl.initialValue \n          ? this.visit(stateDecl.initialValue) \n          : 'null';\n        \n        this.addLine(`this.${name} = createReactiveState(${initialValue});`);\n      }\n      this.addLine(\"\");\n    }\n    \n    // Initialize computed properties\n    if (node.computed.length > 0) {\n      this.addLine(\"// Initialize computed properties\");\n      for (const computedDecl of node.computed) {\n        const name = computedDecl.name.name;\n        this.addLine(`this.${name} = createComputed(() => {`);\n        this.indent++;\n        this.visit(computedDecl.body);\n        this.indent--;\n        this.addLine(\"});\");\n      }\n      this.addLine(\"\");\n    }\n    \n    // Initialize effects\n    if (node.effects.length > 0) {\n      this.addLine(\"// Initialize effects\");\n      for (let i = 0; i < node.effects.length; i++) {\n        const effect = node.effects[i];\n        const deps = effect.dependencies.map(dep => this.visit(dep)).join(', ');\n        \n        this.addLine(`this.effect${i} = createEffect(() => {`);\n        this.indent++;\n        this.visit(effect.body);\n        this.indent--;\n        this.addLine(`}, [${deps}]);`);\n      }\n      this.addLine(\"\");\n    }\n    \n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n    \n    // Generate methods\n    for (const method of node.methods) {\n      this.visitMethodDeclaration(method);\n    }\n    \n    // Generate lifecycle methods\n    for (const lifecycle of node.lifecycle) {\n      this.visitLifecycleDeclaration(lifecycle);\n    }\n    \n    // Generate render method\n    if (node.render) {\n      this.visitRenderDeclaration(node.render);\n    }\n    \n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n    \n    // Add component registration\n    this.addLine(`${componentName}.displayName = '${componentName}';`);\n    \n    // Handle route decorators\n    const routeDecorator = node.decorators.find(d => d.name.name === 'route');\n    if (routeDecorator) {\n      const path = routeDecorator.arguments[0];\n      this.addLine(`FluxRuntime.registerRoute(${this.visit(path)}, ${componentName});`);\n    }\n  }\n\n  visitStoreDeclaration(node) {\n    const storeName = node.name.name;\n    this.storeCount++;\n    \n    this.addLine(`class ${storeName} extends Store {`);\n    this.indent++;\n    \n    // Constructor\n    this.addLine(\"constructor() {\");\n    this.indent++;\n    this.addLine(\"super();\");\n    this.addLine(\"\");\n    \n    // Initialize state\n    if (node.state.length > 0) {\n      this.addLine(\"// Initialize state\");\n      for (const stateDecl of node.state) {\n        const name = stateDecl.name.name;\n        const initialValue = stateDecl.initialValue \n          ? this.visit(stateDecl.initialValue) \n          : 'null';\n        \n        this.addLine(`this.${name} = createReactiveState(${initialValue});`);\n      }\n      this.addLine(\"\");\n    }\n    \n    // Initialize computed properties\n    if (node.computed.length > 0) {\n      this.addLine(\"// Initialize computed properties\");\n      for (const computedDecl of node.computed) {\n        const name = computedDecl.name.name;\n        this.addLine(`this.${name} = createComputed(() => {`);\n        this.indent++;\n        this.visit(computedDecl.body);\n        this.indent--;\n        this.addLine(\"});\");\n      }\n      this.addLine(\"\");\n    }\n    \n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n    \n    // Generate actions\n    for (const action of node.actions) {\n      this.visitActionDeclaration(action);\n    }\n    \n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n    \n    // Create singleton instance\n    this.addLine(`const ${storeName}Instance = new ${storeName}();`);\n    this.addLine(`export { ${storeName}Instance as ${storeName} };`);\n  }\n\n  visitMethodDeclaration(node) {\n    const name = node.name.name;\n    const asyncKeyword = node.isAsync ? 'async ' : '';\n    const params = node.parameters.map(p => p.name.name).join(', ');\n    \n    this.addLine(`${asyncKeyword}${name}(${params}) {`);\n    this.indent++;\n    this.visit(node.body);\n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n  }\n\n  visitActionDeclaration(node) {\n    const name = node.name.name;\n    const asyncKeyword = node.isAsync ? 'async ' : '';\n    const params = node.parameters.map(p => p.name.name).join(', ');\n    \n    this.addLine(`${asyncKeyword}${name}(${params}) {`);\n    this.indent++;\n    this.visit(node.body);\n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n  }\n\n  visitLifecycleDeclaration(node) {\n    const phase = node.phase;\n    const asyncKeyword = node.isAsync ? 'async ' : '';\n    \n    this.addLine(`${asyncKeyword}${phase}() {`);\n    this.indent++;\n    this.visit(node.body);\n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n  }\n\n  visitRenderDeclaration(node) {\n    this.addLine(\"render() {\");\n    this.indent++;\n    this.addLine(\"return (\");\n    this.indent++;\n    this.visit(node.body);\n    this.indent--;\n    this.addLine(\");\");\n    this.indent--;\n    this.addLine(\"}\");\n    this.addLine(\"\");\n  }\n\n  visitBlockStatement(node) {\n    for (let i = 0; i < node.body.length; i++) {\n      this.visit(node.body[i]);\n      \n      // Add semicolon for expression statements\n      if (node.body[i].type === 'ExpressionStatement') {\n        this.add(';');\n      }\n      \n      if (i < node.body.length - 1) {\n        this.addLine(\"\");\n      }\n    }\n  }\n\n  visitExpressionStatement(node) {\n    this.add(this.getIndent());\n    this.visit(node.expression);\n  }\n\n  visitIfStatement(node) {\n    this.add(`${this.getIndent()}if (`);\n    this.visit(node.test);\n    this.add(') ');\n    this.visit(node.consequent);\n    \n    if (node.alternate) {\n      this.add(' else ');\n      this.visit(node.alternate);\n    }\n  }\n\n  visitWhileStatement(node) {\n    this.add(`${this.getIndent()}while (`);\n    this.visit(node.test);\n    this.add(') ');\n    this.visit(node.body);\n  }\n\n  visitForStatement(node) {\n    this.add(`${this.getIndent()}for (`);\n    if (node.init) this.visit(node.init);\n    this.add('; ');\n    if (node.test) this.visit(node.test);\n    this.add('; ');\n    if (node.update) this.visit(node.update);\n    this.add(') ');\n    this.visit(node.body);\n  }\n\n  visitReturnStatement(node) {\n    this.add(`${this.getIndent()}return`);\n    if (node.argument) {\n      this.add(' ');\n      this.visit(node.argument);\n    }\n  }\n\n  visitTryStatement(node) {\n    this.add(`${this.getIndent()}try `);\n    this.visit(node.block);\n    \n    if (node.handler) {\n      this.add(` catch (${node.handler.param.name}) `);\n      this.visit(node.handler.body);\n    }\n    \n    if (node.finalizer) {\n      this.add(' finally ');\n      this.visit(node.finalizer);\n    }\n  }\n\n  visitBinaryExpression(node) {\n    this.visit(node.left);\n    this.add(` ${node.operator} `);\n    this.visit(node.right);\n  }\n\n  visitUnaryExpression(node) {\n    this.add(node.operator);\n    this.visit(node.operand);\n  }\n\n  visitAssignmentExpression(node) {\n    // Handle reactive state assignments\n    if (node.left.type === 'MemberExpression' && \n        node.left.object.type === 'Identifier' &&\n        node.left.object.name === 'this') {\n      \n      // Convert this.state = value to this.state.value = value\n      this.add('this.');\n      this.visit(node.left.property);\n      this.add('.value ');\n      this.add(node.operator);\n      this.add(' ');\n      this.visit(node.right);\n    } else {\n      this.visit(node.left);\n      this.add(` ${node.operator} `);\n      this.visit(node.right);\n    }\n  }\n\n  visitCallExpression(node) {\n    this.visit(node.callee);\n    this.add('(');\n    \n    for (let i = 0; i < node.arguments.length; i++) {\n      this.visit(node.arguments[i]);\n      if (i < node.arguments.length - 1) {\n        this.add(', ');\n      }\n    }\n    \n    this.add(')');\n  }\n\n  visitMemberExpression(node) {\n    this.visit(node.object);\n    \n    if (node.computed) {\n      this.add('[');\n      this.visit(node.property);\n      this.add(']');\n    } else {\n      this.add('.');\n      this.visit(node.property);\n    }\n  }\n\n  visitConditionalExpression(node) {\n    this.visit(node.test);\n    this.add(' ? ');\n    this.visit(node.consequent);\n    this.add(' : ');\n    this.visit(node.alternate);\n  }\n\n  visitArrayExpression(node) {\n    this.add('[');\n    \n    for (let i = 0; i < node.elements.length; i++) {\n      this.visit(node.elements[i]);\n      if (i < node.elements.length - 1) {\n        this.add(', ');\n      }\n    }\n    \n    this.add(']');\n  }\n\n  visitObjectExpression(node) {\n    this.add('{');\n    \n    if (node.properties.length > 0) {\n      this.addLine(\"\");\n      this.indent++;\n      \n      for (let i = 0; i < node.properties.length; i++) {\n        this.add(this.getIndent());\n        this.visit(node.properties[i]);\n        if (i < node.properties.length - 1) {\n          this.add(',');\n        }\n        this.addLine(\"\");\n      }\n      \n      this.indent--;\n      this.add(this.getIndent());\n    }\n    \n    this.add('}');\n  }\n\n  visitProperty(node) {\n    this.visit(node.key);\n    this.add(': ');\n    this.visit(node.value);\n  }\n\n  visitLiteral(node) {\n    if (typeof node.value === 'string') {\n      this.add(JSON.stringify(node.value));\n    } else {\n      this.add(String(node.value));\n    }\n  }\n\n  visitIdentifier(node) {\n    // Handle reactive state access\n    if (this.isInRenderContext() && this.isReactiveState(node.name)) {\n      this.add(`this.${node.name}.value`);\n    } else {\n      this.add(node.name);\n    }\n  }\n\n  visitJSXElement(node) {\n    this.add('createElement(');\n    \n    // Element name\n    if (node.openingElement.name.name.charAt(0).toLowerCase() === node.openingElement.name.name.charAt(0)) {\n      // HTML element\n      this.add(`'${node.openingElement.name.name}'`);\n    } else {\n      // Component\n      this.add(node.openingElement.name.name);\n    }\n    \n    // Props\n    if (node.openingElement.attributes.length > 0) {\n      this.add(', {');\n      \n      for (let i = 0; i < node.openingElement.attributes.length; i++) {\n        const attr = node.openingElement.attributes[i];\n        this.add(`${attr.name.name}: `);\n        \n        if (attr.value.type === 'JSXExpressionContainer') {\n          this.visit(attr.value.expression);\n        } else {\n          this.visit(attr.value);\n        }\n        \n        if (i < node.openingElement.attributes.length - 1) {\n          this.add(', ');\n        }\n      }\n      \n      this.add('}');\n    } else {\n      this.add(', null');\n    }\n    \n    // Children\n    if (node.children.length > 0) {\n      for (const child of node.children) {\n        this.add(', ');\n        \n        if (child.type === 'JSXText') {\n          this.add(JSON.stringify(child.value));\n        } else if (child.type === 'JSXExpressionContainer') {\n          this.visit(child.expression);\n        } else {\n          this.visit(child);\n        }\n      }\n    }\n    \n    this.add(')');\n  }\n\n  visitJSXExpressionContainer(node) {\n    this.visit(node.expression);\n  }\n\n  visitJSXText(node) {\n    this.add(JSON.stringify(node.value));\n  }\n\n  // Utility methods\n  isInRenderContext() {\n    // Simple heuristic - in a real implementation, we'd track context properly\n    return true;\n  }\n\n  isReactiveState(name) {\n    // Check if this identifier refers to a reactive state variable\n    // In a real implementation, we'd have proper scope tracking\n    return true;\n  }\n\n  add(text) {\n    this.output.push(text);\n  }\n\n  addLine(text = \"\") {\n    this.output.push(text + '\\n');\n  }\n\n  getIndent() {\n    return '  '.repeat(this.indent);\n  }\n}\n\n// Runtime optimization helpers\nexport class FluxOptimizer {\n  constructor() {\n    this.optimizations = [\n      this.eliminateDeadCode,\n      this.inlineConstants,\n      this.optimizeReactiveUpdates,\n      this.bundleComponents\n    ];\n  }\n\n  optimize(ast) {\n    let optimizedAst = ast;\n    \n    for (const optimization of this.optimizations) {\n      optimizedAst = optimization(optimizedAst);\n    }\n    \n    return optimizedAst;\n  }\n\n  eliminateDeadCode(ast) {\n    // Remove unused variables, functions, and imports\n    return ast;\n  }\n\n  inlineConstants(ast) {\n    // Inline constant values at compile time\n    return ast;\n  }\n\n  optimizeReactiveUpdates(ast) {\n    // Minimize reactive dependency tracking\n    return ast;\n  }\n\n  bundleComponents(ast) {\n    // Optimize component bundling and code splitting\n    return ast;\n  }\n}", "// flux-core/src/errors.js\n// Error handling system for Flux compiler\n\nexport class FluxError extends Error {\n  constructor(message, details = null) {\n    super(message);\n    this.name = 'FluxError';\n    this.details = details;\n    this.timestamp = new Date();\n  }\n}\n\nexport class LexerError extends FluxError {\n  constructor(message, line, column, source) {\n    super(`Lexer Error: ${message}`);\n    this.name = 'LexerError';\n    this.line = line;\n    this.column = column;\n    this.source = source;\n  }\n  \n  format() {\n    return this.formatError('Lexer Error', this.message);\n  }\n}\n\nexport class ParserError extends FluxError {\n  constructor(message, token, expected = null) {\n    super(`Parser Error: ${message}`);\n    this.name = 'ParserError';\n    this.token = token;\n    this.expected = expected;\n    this.line = token ? token.line : 1;\n    this.column = token ? token.column : 1;\n  }\n  \n  format() {\n    let message = this.message;\n    if (this.expected) {\n      message += ` (expected ${this.expected})`;\n    }\n    return this.formatError('Parser Error', message);\n  }\n}\n\nexport class SemanticError extends FluxError {\n  constructor(message, node, suggestion = null) {\n    super(`Semantic Error: ${message}`);\n    this.name = 'SemanticError';\n    this.node = node;\n    this.suggestion = suggestion;\n    this.line = node ? node.location?.line : 1;\n    this.column = node ? node.location?.column : 1;\n  }\n  \n  format() {\n    let message = this.message;\n    if (this.suggestion) {\n      message += `\\nSuggestion: ${this.suggestion}`;\n    }\n    return this.formatError('Semantic Error', message);\n  }\n}\n\nexport class CodegenError extends FluxError {\n  constructor(message, node, context = null) {\n    super(`Code Generation Error: ${message}`);\n    this.name = 'CodegenError';\n    this.node = node;\n    this.context = context;\n    this.line = node ? node.location?.line : 1;\n    this.column = node ? node.location?.column : 1;\n  }\n  \n  format() {\n    let message = this.message;\n    if (this.context) {\n      message += `\\nContext: ${this.context}`;\n    }\n    return this.formatError('Code Generation Error', message);\n  }\n}\n\nexport class RuntimeError extends FluxError {\n  constructor(message, component = null, stack = null) {\n    super(`Runtime Error: ${message}`);\n    this.name = 'RuntimeError';\n    this.component = component;\n    this.stack = stack;\n  }\n  \n  format() {\n    let message = this.message;\n    if (this.component) {\n      message += `\\nComponent: ${this.component}`;\n    }\n    return this.formatError('Runtime Error', message);\n  }\n}\n\n// Error formatter utility\nexport class ErrorFormatter {\n  static formatError(error, source = null) {\n    if (error.format) {\n      return error.format();\n    }\n    \n    let output = `${error.name}: ${error.message}\\n`;\n    \n    if (error.line && error.column) {\n      output += `at line ${error.line}, column ${error.column}\\n`;\n      \n      if (source) {\n        output += this.formatSourceContext(source, error.line, error.column);\n      }\n    }\n    \n    if (error.stack) {\n      output += `\\nStack trace:\\n${error.stack}`;\n    }\n    \n    return output;\n  }\n  \n  static formatSourceContext(source, line, column, contextLines = 3) {\n    const lines = source.split('\\n');\n    const startLine = Math.max(1, line - contextLines);\n    const endLine = Math.min(lines.length, line + contextLines);\n    \n    let output = '\\nSource context:\\n';\n    \n    for (let i = startLine; i <= endLine; i++) {\n      const marker = i === line ? '>>> ' : '    ';\n      const lineNumber = i.toString().padStart(3);\n      const content = lines[i - 1] || '';\n      \n      output += `${marker}${lineNumber}: ${content}\\n`;\n      \n      if (i === line && column > 0) {\n        const indent = '    ' + ' '.repeat(column - 1);\n        output += `${indent}^\\n`;\n      }\n    }\n    \n    return output;\n  }\n  \n  static formatErrorList(errors, source = null) {\n    if (errors.length === 0) return '';\n    \n    let output = `\\n${errors.length} error(s) found:\\n\\n`;\n    \n    for (let i = 0; i < errors.length; i++) {\n      const error = errors[i];\n      output += `${i + 1}. ${this.formatError(error, source)}\\n`;\n      \n      if (i < errors.length - 1) {\n        output += '\\n';\n      }\n    }\n    \n    return output;\n  }\n}\n\n// Error collector for batch processing\nexport class ErrorCollector {\n  constructor() {\n    this.errors = [];\n    this.warnings = [];\n    this.maxErrors = 100; // Prevent infinite error loops\n  }\n  \n  addError(error) {\n    if (this.errors.length < this.maxErrors) {\n      this.errors.push(error);\n    }\n  }\n  \n  addWarning(warning) {\n    this.warnings.push(warning);\n  }\n  \n  hasErrors() {\n    return this.errors.length > 0;\n  }\n  \n  hasWarnings() {\n    return this.warnings.length > 0;\n  }\n  \n  clear() {\n    this.errors = [];\n    this.warnings = [];\n  }\n  \n  formatAll(source = null) {\n    let output = '';\n    \n    if (this.errors.length > 0) {\n      output += ErrorFormatter.formatErrorList(this.errors, source);\n    }\n    \n    if (this.warnings.length > 0) {\n      output += `\\n${this.warnings.length} warning(s):\\n`;\n      for (const warning of this.warnings) {\n        output += `- ${warning.message}\\n`;\n      }\n    }\n    \n    return output;\n  }\n}", "// flux-core/src/compiler/index.js\n// Main compiler entry point\n\nimport { FluxLexer } from './lexer.js';\nimport { FluxParser } from './parser.js';\nimport { FluxCodeGenerator } from './codegen.js';\nimport { FluxError } from '../errors.js';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nexport class FluxCompiler {\n  constructor(options = {}) {\n    this.options = {\n      target: 'js', // 'js' or 'wasm'\n      minify: false,\n      sourceMaps: true,\n      optimizations: true,\n      outputDir: 'dist',\n      treeShaking: true,\n      codeSplitting: false,\n      bundleAnalysis: false,\n      watchMode: false,\n      incremental: true,\n      parallel: true,\n      maxWorkers: 4,\n      ...options\n    };\n    \n    this.errors = [];\n    this.warnings = [];\n    this.compilationCache = new Map();\n    this.dependencyGraph = new Map();\n    this.optimizer = new FluxOptimizer(this.options);\n    this.bundler = new FluxBundler(this.options);\n  }\n\n  async compileFile(filePath) {\n    try {\n      // Read source file\n      const source = await fs.readFile(filePath, 'utf-8');\n      \n      // Compile source\n      const result = this.compile(source, filePath);\n      \n      if (this.errors.length > 0) {\n        throw new FluxError('Compilation failed', this.errors);\n      }\n      \n      return result;\n    } catch (error) {\n      if (error instanceof FluxError) {\n        throw error;\n      }\n      throw new FluxError(`Failed to read file ${filePath}: ${error.message}`);\n    }\n  }\n\n  compile(source, filePath = '<unknown>') {\n    try {\n      // Reset error state\n      this.errors = [];\n      this.warnings = [];\n      \n      // Tokenize\n      const lexer = new FluxLexer(source);\n      const tokens = lexer.tokenize();\n      \n      if (lexer.errors.length > 0) {\n        this.errors.push(...lexer.errors);\n        return null;\n      }\n      \n      // Parse\n      const parser = new FluxParser(tokens);\n      const ast = parser.program();\n      \n      if (parser.errors.length > 0) {\n        this.errors.push(...parser.errors);\n        return null;\n      }\n      \n      // Generate code\n      const generator = new FluxCodeGenerator(this.options);\n      const output = generator.generate(ast);\n      \n      if (generator.errors.length > 0) {\n        this.errors.push(...generator.errors);\n        return null;\n      }\n      \n      return {\n        source,\n        ast,\n        output,\n        sourceMap: generator.sourceMap,\n        filePath\n      };\n    } catch (error) {\n      this.errors.push({\n        message: error.message,\n        file: filePath,\n        line: 1,\n        column: 1\n      });\n      return null;\n    }\n  }\n\n  async build() {\n    const projectRoot = process.cwd();\n    const fluxConfig = await this.loadConfig(projectRoot);\n    \n    // Find all .flux files\n    const fluxFiles = await this.findFluxFiles(projectRoot);\n    \n    if (fluxFiles.length === 0) {\n      throw new FluxError('No .flux files found in project');\n    }\n    \n    console.log(`Found ${fluxFiles.length} Flux files to compile`);\n    \n    // Compile each file\n    const results = [];\n    for (const file of fluxFiles) {\n      const result = await this.compileFile(file);\n      if (result) {\n        results.push(result);\n      }\n    }\n    \n    if (this.errors.length > 0) {\n      throw new FluxError('Build failed', this.errors);\n    }\n    \n    // Write output files\n    await this.writeBuildOutput(results, projectRoot);\n    \n    return results;\n  }\n\n  async findFluxFiles(rootDir) {\n    const files = [];\n    \n    async function scan(dir) {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        \n        if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {\n          await scan(fullPath);\n        } else if (entry.isFile() && entry.name.endsWith('.flux')) {\n          files.push(fullPath);\n        }\n      }\n    }\n    \n    await scan(rootDir);\n    return files;\n  }\n\n  async loadConfig(projectRoot) {\n    const configPath = path.join(projectRoot, 'flux.config.js');\n    \n    try {\n      if (await fs.pathExists(configPath)) {\n        const config = await import(configPath);\n        return config.default || config;\n      }\n    } catch (error) {\n      console.warn(`Warning: Could not load flux.config.js: ${error.message}`);\n    }\n    \n    return {};\n  }\n\n  async writeBuildOutput(results, projectRoot) {\n    const outputDir = path.join(projectRoot, this.options.outputDir);\n    \n    // Ensure output directory exists\n    await fs.ensureDir(outputDir);\n    \n    // Write compiled files\n    for (const result of results) {\n      const relativePath = path.relative(projectRoot, result.filePath);\n      const outputPath = path.join(\n        outputDir,\n        relativePath.replace(/\\.flux$/, '.js')\n      );\n      \n      await fs.ensureDir(path.dirname(outputPath));\n      await fs.writeFile(outputPath, result.output);\n      \n      // Write source map if enabled\n      if (this.options.sourceMaps && result.sourceMap) {\n        await fs.writeFile(outputPath + '.map', JSON.stringify(result.sourceMap));\n      }\n    }\n    \n    // Write runtime files\n    await this.writeRuntimeFiles(outputDir);\n    \n    // Write index.html if it doesn't exist\n    const indexPath = path.join(outputDir, 'index.html');\n    if (!await fs.pathExists(indexPath)) {\n      await this.writeDefaultIndexHtml(indexPath);\n    }\n  }\n\n  async writeRuntimeFiles(outputDir) {\n    const runtimeDir = path.join(outputDir, 'runtime');\n    await fs.ensureDir(runtimeDir);\n    \n    // Copy runtime files\n    const runtimeSource = path.join(__dirname, '../runtime');\n    await fs.copy(runtimeSource, runtimeDir);\n  }\n\n  async writeDefaultIndexHtml(outputPath) {\n    const html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Flux App</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"./app.js\"></script>\n</body>\n</html>`;\n    \n    await fs.writeFile(outputPath, html);\n  }\n\n  async writeOutput(result, outputPath) {\n    await fs.ensureDir(path.dirname(outputPath));\n    await fs.writeFile(outputPath, result.output);\n    \n    if (this.options.sourceMaps && result.sourceMap) {\n      await fs.writeFile(outputPath + '.map', JSON.stringify(result.sourceMap));\n    }\n  }\n}\n\n// Advanced compiler optimization system\nclass FluxOptimizer {\n  constructor(options) {\n    this.options = options;\n    this.optimizations = new Map();\n    this.analysis = new Map();\n  }\n\n  optimize(ast, context) {\n    if (!this.options.optimizations) return ast;\n    \n    let optimizedAst = ast;\n    \n    // Apply various optimizations\n    optimizedAst = this.constantFolding(optimizedAst);\n    optimizedAst = this.deadCodeElimination(optimizedAst);\n    optimizedAst = this.inlineExpansion(optimizedAst);\n    optimizedAst = this.hoisting(optimizedAst);\n    \n    return optimizedAst;\n  }\n\n  constantFolding(ast) {\n    // Fold constant expressions at compile time\n    return ast;\n  }\n\n  deadCodeElimination(ast) {\n    // Remove unreachable code\n    return ast;\n  }\n\n  inlineExpansion(ast) {\n    // Inline small functions\n    return ast;\n  }\n\n  hoisting(ast) {\n    // Hoist variable declarations\n    return ast;\n  }\n\n  analyze(ast) {\n    // Analyze code for optimization opportunities\n    const analysis = {\n      complexity: this.calculateComplexity(ast),\n      dependencies: this.findDependencies(ast),\n      performance: this.analyzePerformance(ast)\n    };\n    \n    this.analysis.set(ast, analysis);\n    return analysis;\n  }\n\n  calculateComplexity(ast) {\n    // Calculate cyclomatic complexity\n    return 1; // Placeholder\n  }\n\n  findDependencies(ast) {\n    // Find all dependencies\n    return []; // Placeholder\n  }\n\n  analyzePerformance(ast) {\n    // Analyze performance characteristics\n    return {}; // Placeholder\n  }\n}\n\n// Advanced bundling system\nclass FluxBundler {\n  constructor(options) {\n    this.options = options;\n    this.bundles = new Map();\n    this.chunks = new Map();\n  }\n\n  createBundle(entryPoints, dependencies) {\n    if (!this.options.codeSplitting) {\n      return this.createSingleBundle(entryPoints, dependencies);\n    }\n    \n    return this.createSplitBundles(entryPoints, dependencies);\n  }\n\n  createSingleBundle(entryPoints, dependencies) {\n    // Create a single bundle\n    return {\n      type: 'single',\n      code: this.mergeCode(entryPoints, dependencies),\n      sourceMap: this.mergeSourceMaps(entryPoints, dependencies)\n    };\n  }\n\n  createSplitBundles(entryPoints, dependencies) {\n    // Create multiple bundles for code splitting\n    const bundles = [];\n    \n    for (const entryPoint of entryPoints) {\n      const bundle = this.createBundleForEntry(entryPoint, dependencies);\n      bundles.push(bundle);\n    }\n    \n    return bundles;\n  }\n\n  createBundleForEntry(entryPoint, dependencies) {\n    // Create bundle for specific entry point\n    return {\n      type: 'entry',\n      entry: entryPoint,\n      code: this.generateEntryCode(entryPoint, dependencies),\n      dependencies: this.getEntryDependencies(entryPoint, dependencies)\n    };\n  }\n\n  mergeCode(entryPoints, dependencies) {\n    // Merge all code into single output\n    return entryPoints.map(ep => ep.code).join('\\n');\n  }\n\n  mergeSourceMaps(entryPoints, dependencies) {\n    // Merge source maps\n    return {}; // Placeholder\n  }\n\n  generateEntryCode(entryPoint, dependencies) {\n    // Generate code for entry point\n    return entryPoint.code;\n  }\n\n  getEntryDependencies(entryPoint, dependencies) {\n    // Get dependencies for entry point\n    return dependencies.filter(dep => dep.entryPoint === entryPoint);\n  }\n}"],
  "mappings": "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",
  "names": ["path"]
}
